<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Alma Bridge Newt Crosser</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LZ4SSN195H"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-LZ4SSN195H');
    </script>
    
    <style>
        :root {
            --primary-bg: #1a1a2a;
            --secondary-bg: #2a2a3a;
            --text-color: #f0f0f0;
            --accent-color: #50e3c2;
            --road-color: #6c6c7c;
            --water-color: #3b6fa5;
            --forest-color: #2e8b57;
            --danger-color: #e35050;
            --trunk-color: #5d4037;
        }

        body {
            background-color: var(--primary-bg);
            color: var(--text-color);
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            height: 100dvh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
            overflow: hidden;
        }

        #game-container {
            width: 100%;
            max-width: 800px;
            aspect-ratio: 4 / 3;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-shrink: 1;
        }
        
        canvas {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            width: 100%;
            height: 100%;
            display: block;
        }

        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 100;
            padding: 2rem;
            box-sizing: border-box;
            transition: opacity 0.5s ease-out;
        }

        .splash-title {
            font-size: clamp(2.5rem, 6vw, 4rem);
            font-weight: 700;
            color: var(--accent-color);
            margin-bottom: 1rem;
            text-shadow: 0 0 15px var(--accent-color);
        }

        .splash-subtitle {
            font-size: clamp(1rem, 2.5vw, 1.25rem);
            max-width: 600px;
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        
        .splash-link {
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            background: rgba(255,255,255,0.1);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            margin-bottom: 2.5rem;
        }

        .splash-link a {
            color: var(--accent-color);
            font-weight: 600;
            text-decoration: none;
        }

        .play-button {
            font-family: 'Poppins', sans-serif;
            background: var(--accent-color);
            color: var(--primary-bg);
            border: none;
            padding: 1rem 3rem;
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 5px 20px rgba(80, 227, 194, 0.4);
        }
        
        .play-button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(80, 227, 194, 0.6);
        }
        
        #mobile-controls {
            display: none;
            margin-top: 1rem;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        body.touch-enabled #mobile-controls {
             display: grid;
             grid-template-columns: repeat(3, 1fr);
             width: 180px;
             justify-items: center;
             align-items: center;
        }

        #mobile-controls button {
            width: 50px;
            height: 50px;
            background: var(--secondary-bg);
            border: 2px solid var(--accent-color);
            color: var(--accent-color);
            font-size: 1.5rem;
            border-radius: 50%;
            font-weight: bold;
            cursor: pointer;
        }
        
        body.touch-enabled #mobile-controls .up { grid-column: 2; grid-row: 1; }
        body.touch-enabled #mobile-controls .left { grid-column: 1; grid-row: 2; }
        body.touch-enabled #mobile-controls .down { grid-column: 2; grid-row: 2; }
        body.touch-enabled #mobile-controls .right { grid-column: 3; grid-row: 2; }

        @media (max-width: 768px) and (orientation: portrait) {
            body {
                justify-content: space-between;
            }
            #game-container {
                width: 100%;
                height: 70vh;
                max-width: none;
                aspect-ratio: unset;
            }
        }
        
    </style>
</head>
<body>

    <div id="splash-screen">
        <h1 class="splash-title">Newt Crosser</h1>
        <p class="splash-subtitle">Use the Arrow Keys, on-screen controls, or swipe to help the newts safely cross the road. Don't get squished!</p>
        <div class="splash-link">
             To learn more about the plight of the newts crossing Alma Bridge Road, visit <a href="http://bioblitz.club/newts" target="_blank">bioblitz.club/newts</a>
        </div>
        <button class="play-button" id="playGameBtn">Play Game</button>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>
    
    <div id="mobile-controls">
        <button class="up" data-key="ArrowUp">▲</button>
        <button class="left" data-key="ArrowLeft">◄</button>
        <button class="down" data-key="ArrowDown">▼</button>
        <button class="right" data-key="ArrowRight">►</button>
    </div>


    <script>
        const splashScreen = document.getElementById('splash-screen');
        const playGameBtn = document.getElementById('playGameBtn');
        const canvas = document.getElementById("gameCanvas");
        const mobileControls = document.getElementById('mobile-controls');
        const ctx = canvas.getContext("2d");

        let TILE_SIZE = 40;
        let ROAD_TOP_Y, ROAD_BOTTOM_Y, ROAD_CENTER_Y;
        let score = 0;
        let highScore = 0;
        let lives = 3;
        let gameOver = false;
        let gameStarted = false;
        let newt, vehicles = [], scenery = { trees: [], waitingNewts: [], splats: [] };
        let cleaner;
        let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;
        let gameTime = 0;
        
        const carColors = ["#B71C1C", "#1A237E", "#004D40", "#E65100", "#4A148C", "#37474F", "#C51162", "#d4ac0d"];
        const vehicleTemplates = {
            car: { width: 2.8, heightMultiplier: 1.5, speedMultiplier: 1.0, draw: drawCar },
            truck: { width: 4.5, heightMultiplier: 2.8, speedMultiplier: 0.8, draw: drawTruck },
            kayakCar: { width: 2.8, heightMultiplier: 1.5, speedMultiplier: 0.9, draw: drawKayakCar },
            motorcycle: { width: 2.0, heightMultiplier: 1.5, speedMultiplier: 1.5, draw: drawMotorcycle },
            bicycle: { width: 1.5, heightMultiplier: 1.5, speedMultiplier: 0.6, draw: drawBicycle },
        };
        const weightedVehicleTypes = ["car", "car", "car", "truck", "kayakCar", "motorcycle", "bicycle", "truck"];

        function setCanvasDimensions() {
            const container = document.getElementById('game-container');
            const { width, height } = container.getBoundingClientRect();
            canvas.width = width;
            canvas.height = height;
            
            TILE_SIZE = canvas.height / 18;
            ROAD_CENTER_Y = canvas.height / 2;
            ROAD_TOP_Y = ROAD_CENTER_Y - TILE_SIZE * 3;
            ROAD_BOTTOM_Y = ROAD_CENTER_Y + TILE_SIZE * 3;
        }

        function resetNewt() {
            newt = {
                width: TILE_SIZE * 0.7,
                height: TILE_SIZE * 0.9,
                x: canvas.width / 2 - (TILE_SIZE * 0.7) / 2,
                y: canvas.height - TILE_SIZE * 1.5,
                speed: TILE_SIZE * 1.5,
                rotation: 0,
                targetRotation: 0,
                walkPhase: 0,
            };
        }

        function initCleaner() {
            cleaner = {
                x: -TILE_SIZE * 2,
                y: 0,
                width: TILE_SIZE * 1.2,
                height: TILE_SIZE * 2,
                speed: TILE_SIZE * 0.05,
                isActive: false,
                state: 'idle',
                targetSplat: null,
                cleaningStartTime: 0,
                walkPhase: 0,
                direction: 'right',
                exitSide: 'left'
            };
        }

        function init() {
            setCanvasDimensions();
            score = 0;
            lives = 3;
            gameOver = false;
            highScore = parseInt(localStorage.getItem('newtHighScore')) || 0;
            resetNewt();
            initCleaner();
            createScenery();
            createVehicles();
            if (!gameStarted) {
                draw();
            }
        }
        
        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            splashScreen.style.opacity = '0';
            splashScreen.style.pointerEvents = 'none';
            init();
            gameLoop();
            
            // --- Google Analytics Event ---
            // Tracks when a user starts playing the game.
            gtag('event', 'start_game', {
                'event_category': 'Game',
                'event_label': 'Play Button Clicked'
            });
        }

        function restartGame() {
            if (!gameOver) return;
            gameStarted = true;
            init();
            gameLoop();
             // --- Google Analytics Event ---
            // Tracks when a user restarts the game after a game over.
            gtag('event', 'restart_game', {
                'event_category': 'Game',
                'event_label': 'Game Restarted'
            });
        }
        
        function createScenery() {
            scenery.trees = [];
            scenery.waitingNewts = [];
            scenery.splats = [];

            const numWaitingNewts = Math.floor(Math.random() * 5) + 5;
            for(let i = 0; i < numWaitingNewts; i++) {
                scenery.waitingNewts.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (ROAD_TOP_Y - TILE_SIZE) + TILE_SIZE / 2,
                    size: (Math.random() * 0.3 + 0.4) * TILE_SIZE
                });
            }

            for(let i = 0; i < canvas.width / (TILE_SIZE * 4); i++) {
                 scenery.trees.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (ROAD_TOP_Y - TILE_SIZE * 2.5) + TILE_SIZE * 2,
                    trunkWidth: (Math.random() * 0.2 + 0.15) * TILE_SIZE,
                    trunkHeight: (Math.random() * 0.6 + 0.4) * TILE_SIZE,
                    canopyLayers: [
                        { dy: 0, radius: (Math.random() * 0.4 + 0.8) * TILE_SIZE, color: '#1e5b3a' },
                        { dy: -TILE_SIZE * 0.3, radius: (Math.random() * 0.4 + 0.7) * TILE_SIZE, color: '#277a4d' },
                        { dy: -TILE_SIZE * 0.5, radius: (Math.random() * 0.3 + 0.6) * TILE_SIZE, color: '#2e8b57' },
                    ]
                });
            }
            scenery.trees.sort((a,b) => a.y - b.y);
        }

        function createVehicles() {
            vehicles = [];
            const lanes = [
                { y: ROAD_CENTER_Y - TILE_SIZE * 1.8, speed: -2.8 }, 
                { y: ROAD_CENTER_Y + TILE_SIZE * 0.3, speed: 2.2 },
            ];
            lanes.forEach(lane => {
                const numVehicles = Math.floor(Math.random() * 2) + 4; 
                for (let i = 0; i < numVehicles; i++) {
                    const typeKey = weightedVehicleTypes[Math.floor(Math.random() * weightedVehicleTypes.length)];
                    const template = vehicleTemplates[typeKey];
                    vehicles.push({
                        type: typeKey,
                        x: Math.random() * canvas.width * 1.5 + i * (canvas.width * 1.8 / numVehicles), 
                        y: lane.y,
                        width: TILE_SIZE * template.width,
                        height: TILE_SIZE * template.heightMultiplier,
                        baseSpeed: lane.speed * (TILE_SIZE / 40),
                        color: carColors[Math.floor(Math.random() * carColors.length)],
                    });
                }
            });
        }
        
        playGameBtn.addEventListener('click', startGame);
        document.addEventListener("keydown", e => handleInput(e.key));

        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            document.body.classList.add('touch-enabled');
        }
        
        mobileControls.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                handleInput(e.target.dataset.key);
            }
        });
        
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            if (gameOver) {
                restartGame();
                return;
            }
            touchStartX = e.changedTouches[0].clientX;
            touchStartY = e.changedTouches[0].clientY;
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            touchEndX = e.changedTouches[0].clientX;
            touchEndY = e.changedTouches[0].clientY;
            handleSwipe();
        }, { passive: false });

        window.addEventListener('resize', () => {
            setTimeout(() => {
                const wasRunning = gameStarted && !gameOver;
                init();
                if (wasRunning) {
                    gameStarted = true;
                    draw();
                }
            }, 250);
        });

        function handleSwipe() {
            if (gameOver) return;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            const swipeThreshold = 30;

            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > swipeThreshold) {
                    handleInput(dx > 0 ? 'ArrowRight' : 'ArrowLeft');
                }
            } else {
                if (Math.abs(dy) > swipeThreshold) {
                    handleInput(dy > 0 ? 'ArrowDown' : 'ArrowUp');
                }
            }
        }

        function handleInput(key) {
             if (gameOver) {
                if (key === "Enter") {
                    restartGame();
                }
                return;
            }
            
            if (!newt) return;

            if (!gameStarted) startGame();

            switch (key) {
                case "ArrowUp": newt.y -= newt.speed; newt.targetRotation = 0; break;
                case "ArrowDown": if (newt.y < canvas.height - newt.height * 2) newt.y += newt.speed; newt.targetRotation = Math.PI; break;
                case "ArrowLeft": if (newt.x > 0) newt.x -= newt.speed; newt.targetRotation = -Math.PI / 2; break;
                case "ArrowRight": if (newt.x < canvas.width - newt.width) newt.x += newt.speed; newt.targetRotation = Math.PI / 2; break;
            }
        }

        function update() {
            if (gameOver) return;
            if (gameStarted && newt) {
                newt.walkPhase = (gameTime / 200) % (Math.PI * 2);
            }
            if (newt) {
                let dy = newt.targetRotation - newt.rotation;
                if (Math.abs(dy) > Math.PI) dy = dy < 0 ? dy + 2 * Math.PI : dy - 2 * Math.PI;
                newt.rotation += dy * 0.2;
            }

            const difficultyFactor = 1 + (score / 20);

            vehicles.forEach(v => {
                v.x += v.baseSpeed * difficultyFactor;
                if (v.baseSpeed > 0 && v.x > canvas.width + v.width) v.x = -v.width;
                else if (v.baseSpeed < 0 && v.x < -v.width * 2) v.x = canvas.width + v.width;
            });

            vehicles.forEach(v => {
                if (newt && newt.x < v.x + v.width && newt.x + newt.width > v.x && newt.y < v.y + v.height && newt.y + newt.height > v.y) {
                    handleCollision();
                }
            });

            if (newt && newt.y < ROAD_TOP_Y) {
                handleSuccess();
            }

            updateCleaner();
        }
        
        function activateCleaner(splat) {
            cleaner.isActive = true;
            cleaner.targetSplat = splat;
            cleaner.state = 'entering';

            const startOnLeft = splat.x < canvas.width / 2;
            cleaner.x = startOnLeft ? -cleaner.width * 2 : canvas.width + cleaner.width * 2;
            cleaner.y = ROAD_BOTTOM_Y + TILE_SIZE; 
            cleaner.direction = startOnLeft ? 'right' : 'left';
        }

        function updateCleaner() {
            if (!cleaner.isActive) return;

            cleaner.walkPhase = (gameTime / 150) % (Math.PI * 2);
            const cleaningDuration = 1500;

            const isExiting = cleaner.state === 'exiting';
            const targetX = isExiting ? (cleaner.exitSide === 'left' ? -cleaner.width * 2 : canvas.width + cleaner.width) : cleaner.targetSplat.x - cleaner.width / 2;
            const targetY = isExiting ? ROAD_BOTTOM_Y + TILE_SIZE : cleaner.targetSplat.y - cleaner.height / 2;

            const dx = targetX - cleaner.x;
            const dy = targetY - cleaner.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (cleaner.state === 'cleaning') {
                if (gameTime - cleaner.cleaningStartTime > cleaningDuration) {
                    scenery.splats = scenery.splats.filter(s => s.id !== cleaner.targetSplat.id);
                    cleaner.targetSplat = null;
                    cleaner.state = 'exiting';
                    cleaner.exitSide = cleaner.x < canvas.width / 2 ? 'right' : 'left'; 
                }
                return; 
            }

            if (distance < cleaner.speed * 1.5) {
                if (!isExiting) {
                    cleaner.state = 'cleaning';
                    cleaner.cleaningStartTime = gameTime;
                } else { 
                    cleaner.isActive = false;
                    cleaner.state = 'idle';
                    if (scenery.splats.length > 0) {
                        activateCleaner(scenery.splats[0]);
                    }
                }
                return;
            }
            
            let canMove = true;
            let moveX = 0;
            let moveY = 0;

            if (Math.abs(dy) > cleaner.speed) {
                moveY = Math.sign(dy) * cleaner.speed;
            } else { 
                moveX = Math.sign(dx) * cleaner.speed;
                cleaner.direction = moveX > 0 ? 'right' : 'left';

                if (cleaner.y > ROAD_TOP_Y && cleaner.y < ROAD_BOTTOM_Y) {
                    const safetyBuffer = TILE_SIZE * 4; 
                    for (const v of vehicles) {
                        if (Math.abs(v.y - cleaner.y) < TILE_SIZE * 1.5) {
                            const cleanerFront = cleaner.x + (cleaner.direction === 'right' ? cleaner.width : 0);
                            
                            if (cleaner.direction === 'right' && v.baseSpeed < 0 && v.x + v.width > cleanerFront && v.x < cleanerFront + safetyBuffer) {
                                canMove = false;
                                break;
                            }
                            if (cleaner.direction === 'left' && v.baseSpeed > 0 && v.x < cleanerFront && v.x + v.width > cleanerFront - safetyBuffer) {
                                canMove = false;
                                break;
                            }
                        }
                    }
                }
            }
            
            if (canMove) {
                cleaner.x += moveX;
                cleaner.y += moveY;
            }
        }

        function handleCollision() {
            if (!newt) return;
            
            const newSplat = {
                x: newt.x + newt.width / 2,
                y: newt.y + newt.height / 2,
                creationTime: gameTime,
                maxRadius: TILE_SIZE * 0.8,
                id: Date.now() + Math.random()
            };
            scenery.splats.push(newSplat);
            
            if (!cleaner.isActive) {
                activateCleaner(newSplat);
            }

            newt = null;
            lives--;

            if (lives <= 0) {
                gameOver = true;
                
                // --- Google Analytics Event ---
                // Tracks when the game ends and sends the final score.
                gtag('event', 'game_over', {
                    'event_category': 'Game',
                    'event_label': 'Player Lost',
                    'value': score // Sending the final score as the event value
                });

                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('newtHighScore', highScore);
                     // --- Google Analytics Event ---
                    // Tracks when a new high score is achieved.
                    gtag('event', 'new_high_score', {
                        'event_category': 'Game',
                        'event_label': 'New High Score Achieved',
                        'value': highScore
                    });
                }
            } else {
                setTimeout(resetNewt, 500);
            }
        }

        function handleSuccess() {
            score++;
            resetNewt();
            
            // --- Google Analytics Event ---
            // Tracks each time a newt successfully crosses the road.
            gtag('event', 'newt_crossed', {
                'event_category': 'Game',
                'event_label': 'Successful Crossing',
                'value': score // You can track the current score at each success
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();

            scenery.splats.forEach(drawSplat);
            drawHumanCleaner();
            
            vehicles.forEach(v => {
                const template = vehicleTemplates[v.type];
                template.draw(v.x, v.y, v.width, v.height, v.color, v.baseSpeed);
            });
            
            if (gameStarted && !gameOver && newt) {
                drawNewt(newt.x, newt.y, newt.width, newt.height);
            }
            
            drawUI();

            if (gameOver) {
                drawGameOver();
            }
        }

        function drawNewt(x, y, w, h) {
            ctx.save();
            ctx.translate(x + w / 2, y + h / 2);
            ctx.rotate(newt.rotation);

            const walkCycle = Math.sin(newt.walkPhase);
            const legShift = walkCycle * (w * 0.08);
            const legColor = "#af7d1c";
            const legLength = w * 0.3;  
            const legThickness = h * 0.15; 
            const bodySide = w * 0.35;    

            ctx.fillStyle = legColor;
            ctx.fillRect(-bodySide - legLength + legShift, -h * 0.2, legLength, legThickness);
            ctx.fillRect(bodySide + legShift, h * 0.2 - legThickness, legLength, legThickness);
            ctx.fillRect(bodySide - legShift, -h * 0.2, legLength, legThickness);
            ctx.fillRect(-bodySide - legLength - legShift, h * 0.2 - legThickness, legLength, legThickness);

            ctx.fillStyle = "#cf8e23";
            ctx.beginPath();
            ctx.ellipse(0, h * 0.6, w * 0.2, h * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#e59f28";
            ctx.beginPath();
            ctx.ellipse(0, 0, w * 0.45, h * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "#f5d47a";
            ctx.beginPath();
            ctx.ellipse(0, 0, w * 0.35, h * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#e59f28";
            ctx.beginPath();
            ctx.ellipse(0, -h * 0.4, w * 0.4, h * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(-w * 0.15, -h * 0.45, w * 0.05, 0, Math.PI * 2);
            ctx.arc(w * 0.15, -h * 0.45, w * 0.05, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
        
        function drawHumanCleaner() {
            if (!cleaner.isActive) return;

            ctx.save();
            ctx.translate(cleaner.x, cleaner.y);

            const w = cleaner.width;
            const h = cleaner.height;
            const walkCycle = Math.sin(cleaner.walkPhase);
            const bob = Math.sin(cleaner.walkPhase * 2) * (TILE_SIZE * 0.05);

            ctx.strokeStyle = "#a0522d";
            ctx.lineWidth = w * 0.1;
            ctx.beginPath();
            ctx.moveTo(w * 0.5, h * 0.5 + bob);
            const mopAngle = cleaner.direction === 'right' ? Math.PI / 4 : (3 * Math.PI) / 4;
            const mopEndX = w * 0.5 + Math.cos(mopAngle) * w;
            const mopEndY = h * 0.5 + bob + Math.sin(mopAngle) * w;
            ctx.lineTo(mopEndX, mopEndY);
            ctx.stroke();

            if (cleaner.state === 'cleaning') {
                const cleaningProgress = (gameTime - cleaner.cleaningStartTime) / 1000;
                const mopHeadX = cleaner.targetSplat.x - cleaner.x + Math.sin(cleaningProgress * Math.PI * 6) * (w * 0.5);
                const mopHeadY = cleaner.targetSplat.y - cleaner.y;
                ctx.fillStyle = "#e6e6e6";
                ctx.beginPath();
                ctx.ellipse(mopHeadX, mopHeadY, w * 0.4, w * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = "#2c3e50";
            const legShift = walkCycle * (w * 0.2);
            ctx.fillRect(w * 0.3 - legShift, h * 0.6 + bob, w * 0.2, h * 0.4);
            ctx.fillRect(w * 0.5 + legShift, h * 0.6 + bob, w * 0.2, h * 0.4);
            
            ctx.fillStyle = "#f39c12";
            ctx.fillRect(w * 0.15, h * 0.2 + bob, w * 0.7, h * 0.4);
            
            ctx.fillStyle = "#bdc3c7";
            ctx.fillRect(w * 0.1, h * 0.4 + bob, w * 0.8, h * 0.08);

            ctx.fillStyle = "#f1c40f";
            ctx.beginPath();
            ctx.arc(w * 0.5, h * 0.15 + bob, w * 0.25, Math.PI, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#e67e22";
            ctx.beginPath();
            ctx.arc(w * 0.5, h * 0.15 + bob, w * 0.2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawSplat(splat) {
            const age = gameTime - splat.creationTime;
            const maxLife = 3000;
            const opacity = 1 - (age / maxLife);

            ctx.save();
            ctx.fillStyle = `rgba(107, 142, 35, 0.7)`;
            ctx.beginPath();
            ctx.ellipse(splat.x, splat.y, splat.maxRadius, splat.maxRadius * 0.7, Math.PI / 4, 0, Math.PI * 2);
            ctx.ellipse(splat.x + 5, splat.y - 5, splat.maxRadius * 0.5, splat.maxRadius * 0.8, Math.PI / 2, 0, Math.PI * 2);
            ctx.ellipse(splat.x - 5, splat.y + 5, splat.maxRadius * 0.9, splat.maxRadius * 0.6, -Math.PI / 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawWaitingNewt(x, y, size) {
            ctx.save();
            ctx.fillStyle = "#d95f26"; 
            ctx.globalAlpha = 0.7; 
            ctx.beginPath();
            ctx.ellipse(x, y, size * 0.4, size * 0.5, 0, 0, Math.PI * 2);
            ctx.ellipse(x, y - size * 0.4, size * 0.3, size * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
            ctx.restore();
        }
        
        function drawBackground() {
            ctx.fillStyle = "#277a4d";
            ctx.fillRect(0, 0, canvas.width, ROAD_TOP_Y);
            
            scenery.waitingNewts.forEach(n => drawWaitingNewt(n.x, n.y, n.size));
            scenery.trees.forEach(tree => {
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--trunk-color');
                ctx.fillRect(tree.x - tree.trunkWidth / 2, tree.y - tree.trunkHeight, tree.trunkWidth, tree.trunkHeight);
                tree.canopyLayers.forEach(layer => {
                     ctx.fillStyle = layer.color;
                     ctx.beginPath();
                     ctx.arc(tree.x, tree.y - tree.trunkHeight + layer.dy, layer.radius, 0, Math.PI * 2);
                     ctx.fill();
                });
            });

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--road-color');
            ctx.fillRect(0, ROAD_TOP_Y, canvas.width, ROAD_BOTTOM_Y - ROAD_TOP_Y);
            
            ctx.font = `bold ${TILE_SIZE * 0.8}px 'Poppins'`;
            ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Alma Bridge Road", canvas.width / 2, ROAD_CENTER_Y);

            ctx.strokeStyle = "#ffd700";
            ctx.lineWidth = 6;
            ctx.setLineDash([TILE_SIZE * 0.8, TILE_SIZE * 0.9]);
            ctx.beginPath();
            ctx.moveTo(0, ROAD_CENTER_Y);
            ctx.lineTo(canvas.width, ROAD_CENTER_Y);
            ctx.stroke();
            ctx.setLineDash([]);

            const waterY = ROAD_BOTTOM_Y;
            const waterHeight = canvas.height - waterY;
            const grad = ctx.createLinearGradient(0, waterY, 0, canvas.height);
            grad.addColorStop(0, "#3b6fa5");
            grad.addColorStop(1, "#2a4d75");
            ctx.fillStyle = grad;
            ctx.fillRect(0, waterY, canvas.width, waterHeight);
            
            ctx.font = `bold ${TILE_SIZE * 0.8}px 'Poppins'`;
            ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Lexington Reservoir", canvas.width / 2, waterY + waterHeight / 2);
        }
        
        function drawCar(x, y, w, h, color, speed) {
            ctx.save();
            ctx.translate(x,y);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(w / 2, h * 0.9, w/2 * 1.1, h * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#222";
            ctx.beginPath();
            ctx.arc(w * 0.2, h * 0.85, h * 0.18, 0, Math.PI * 2);
            ctx.arc(w * 0.75, h * 0.85, h * 0.18, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = color;
            ctx.roundRect(0, h * 0.3, w, h * 0.5, h * 0.1);
            ctx.fill();
            ctx.fillStyle = "rgba(230, 245, 255, 0.8)";
            ctx.beginPath();
            const cabinX = w * 0.15;
            const cabinW = w * 0.7;
            ctx.moveTo(cabinX, h * 0.3);
            ctx.lineTo(cabinX + w * 0.1, h * 0.1);
            ctx.lineTo(cabinX + cabinW - w * 0.1, h * 0.1);
            ctx.lineTo(cabinX + cabinW, h * 0.3);
            ctx.closePath();
            ctx.fill();

            if (speed > 0) {
                drawHeadlight(w - 2, h * 0.55, h * 0.12);
                drawTaillight(2, h * 0.55, h * 0.12);    
            } else {
                drawHeadlight(2, h * 0.55, h * 0.12);    
                drawTaillight(w - 2, h * 0.55, h * 0.12); 
            }
            ctx.restore();
        }

        function drawTruck(x, y, w, h, color, speed) {
            ctx.save();
            ctx.translate(x, y);

            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(w / 2, h * 0.9, w / 2 * 1.05, h * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            const cabWidth = w * 0.3;
            const trailerWidth = w * 0.65;
            const gap = w * 0.05;

            const cabX = speed > 0 ? trailerWidth + gap : 0;
            const trailerX = speed > 0 ? 0 : cabWidth + gap;
            
            const cabFrontX = speed > 0 ? cabX + cabWidth : cabX;
            const trailerBackX = speed > 0 ? trailerX : trailerX + trailerWidth;

            ctx.fillStyle = "#bdc3c7";
            ctx.roundRect(trailerX, h * 0.1, trailerWidth, h * 0.8, h * 0.05);
            ctx.fill();
            ctx.fillStyle = "#95a5a6";
            ctx.fillRect(trailerX + trailerWidth * 0.05, h * 0.7, trailerWidth * 0.9, h * 0.2);

            ctx.fillStyle = color;
            ctx.roundRect(cabX, h * 0.2, cabWidth, h * 0.7, h * 0.1);
            ctx.fill();

            ctx.fillStyle = "rgba(230, 245, 255, 0.8)";
            ctx.roundRect(cabX + cabWidth * 0.1, h * 0.3, cabWidth * 0.8, h * 0.3, h * 0.05);
            ctx.fill();

            ctx.fillStyle = "#222";
            ctx.beginPath();
            ctx.arc(trailerX + trailerWidth * 0.3, h * 0.9, h * 0.15, 0, Math.PI * 2);
            ctx.arc(trailerX + trailerWidth * 0.7, h * 0.9, h * 0.15, 0, Math.PI * 2);
            ctx.arc(cabX + cabWidth * 0.6, h * 0.9, h * 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            drawHeadlight(cabFrontX, h * 0.5, h * 0.15);
            drawTaillight(trailerBackX, h * 0.5, h * 0.15);
            ctx.restore();
        }
        
        function drawHeadlight(x, y, size) {
            const glowSize = size * 2.5;
            const lightGradient = ctx.createRadialGradient(x, y, size * 0.2, x, y, glowSize);
            lightGradient.addColorStop(0, 'rgba(255, 255, 224, 1)');
            lightGradient.addColorStop(0.3, 'rgba(255, 255, 224, 0.8)');
            lightGradient.addColorStop(1, 'rgba(255, 255, 224, 0)');
            ctx.fillStyle = lightGradient;
            ctx.fillRect(x - glowSize, y - glowSize, glowSize * 2, glowSize * 2);
        }
        
        function drawTaillight(x, y, size) {
             const glowSize = size * 2;
             const lightGradient = ctx.createRadialGradient(x, y, size * 0.3, x, y, glowSize);
             lightGradient.addColorStop(0, 'rgba(255, 20, 20, 1)');
             lightGradient.addColorStop(0.5, 'rgba(200, 0, 0, 0.5)');
             lightGradient.addColorStop(1, 'rgba(150, 0, 0, 0)');
             ctx.fillStyle = lightGradient;
             ctx.fillRect(x - glowSize, y - glowSize, glowSize * 2, glowSize * 2);
        }

        function drawKayakCar(x, y, w, h, color, speed) {
            drawCar(x, y, w, h, color, speed);
            ctx.fillStyle = "#d95f26";
            ctx.beginPath();
            ctx.ellipse(x + w / 2, y + h*0.05, w * 0.4, h * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMotorcycle(x, y, w, h, color, speed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            ctx.ellipse(w / 2, h * 0.85, w/2, h * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#333'; ctx.lineWidth = w * 0.05;
            ctx.beginPath();
            ctx.arc(w * 0.15, h * 0.75, h * 0.2, 0, Math.PI * 2);
            ctx.arc(w * 0.85, h * 0.75, h * 0.2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(w * 0.15, h * 0.75);
            ctx.lineTo(w * 0.4, h * 0.4);
            ctx.lineTo(w * 0.85, h * 0.75);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawBicycle(x, y, w, h, color, speed) {
             ctx.save();
            ctx.translate(x, y);
             ctx.strokeStyle = '#555'; ctx.lineWidth = w * 0.08;
            ctx.beginPath();
            ctx.arc(w * 0.15, h * 0.8, h * 0.18, 0, Math.PI * 2);
            ctx.arc(w * 0.85, h * 0.8, h * 0.18, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = color; ctx.lineWidth = w * 0.06;
            ctx.beginPath();
            ctx.moveTo(w * 0.15, h * 0.8);
            ctx.lineTo(w * 0.5, h * 0.4);
            ctx.lineTo(w * 0.85, h * 0.8);
            ctx.stroke();
            ctx.restore();
        }

        function drawUI() {
            ctx.save();
            ctx.font = `600 ${TILE_SIZE * 0.5}px 'Poppins'`;
            
            ctx.textAlign = "left";
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.roundRect(15, 15, TILE_SIZE * 3.5, TILE_SIZE * 1, 10);
            ctx.fill();
            ctx.fillStyle = "white";
            ctx.fillText(`Score: ${score}`, 25, 15 + TILE_SIZE * 0.65);
            
            ctx.textAlign = "right";
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.roundRect(canvas.width - TILE_SIZE * 3.5 - 15, 15, TILE_SIZE * 3.5, TILE_SIZE * 1, 10);
            ctx.fill();
            ctx.fillStyle = "white";
            ctx.fillText(`Lives: ${lives}`, canvas.width - 25, 15 + TILE_SIZE * 0.65);

            ctx.textAlign = "center";
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.roundRect(canvas.width / 2 - TILE_SIZE * 3, 15, TILE_SIZE * 6, TILE_SIZE * 1, 10);
            ctx.fill();
            ctx.fillStyle = "white";
            ctx.fillText(`High Score: ${highScore}`, canvas.width / 2, 15 + TILE_SIZE * 0.65);

            ctx.restore();
        }

        function drawGameOver() {
            const isNewHighScore = score > 0 && score === highScore;
            ctx.fillStyle = "rgba(26, 26, 42, 0.85)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--danger-color');
            ctx.textAlign = "center";
            ctx.font = `bold ${TILE_SIZE * 1.5}px 'Poppins'`;
            ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - TILE_SIZE * 1.5);

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-color');
            ctx.font = `600 ${TILE_SIZE * 0.8}px 'Poppins'`;
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 - TILE_SIZE * 0.2);
            
            ctx.fillStyle = "#f0f0f0";
            ctx.font = `400 ${TILE_SIZE * 0.6}px 'Poppins'`;
            ctx.fillText(`High Score: ${highScore}`, canvas.width / 2, canvas.height / 2 + TILE_SIZE * 0.8);
            
            if (isNewHighScore) {
                ctx.fillStyle = "#ffd700";
                ctx.font = `600 ${TILE_SIZE * 0.7}px 'Poppins'`;
                ctx.fillText("New High Score!", canvas.width / 2, canvas.height / 2 + TILE_SIZE * 2);
            }

            ctx.fillStyle = "white";
            ctx.font = `400 ${TILE_SIZE * 0.5}px 'Poppins'`;
            ctx.fillText("Tap or Press Enter to Restart", canvas.width / 2, canvas.height / 2 + TILE_SIZE * (isNewHighScore ? 3.2 : 2.5));
        }

        let lastFrameTime = 0;
        function gameLoop(timestamp) {
            if (!lastFrameTime) {
                lastFrameTime = timestamp;
            }
            let deltaTime = (timestamp - lastFrameTime) / 1000;
            lastFrameTime = timestamp;
            gameTime = timestamp;

            if (gameOver) {
                draw();
                return;
            }
            
            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        init();

    </script>
</body>
</html>
