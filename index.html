<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Alma Bridge Newt Crosser</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LZ4SSN195H"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-LZ4SSN195H');
    </script>

    <style>
        :root {
            --primary-bg: #1a1a2a;
            --secondary-bg: #2a2a3a;
            --text-color: #f0f0f0;
            --accent-color: #50e3c2;
            --road-color: #6c6c7c;
            --water-color: #3b6fa5;
            --forest-color: #2e8b57;
            --danger-color: #e35050;
            --trunk-color: #5d4037;
        }

        body {
            background: radial-gradient(1200px 600px at 10% 10%, #16202b 0%, var(--primary-bg) 25%, #0f1720 100%), linear-gradient(180deg, rgba(80, 227, 194, 0.03), rgba(0, 0, 0, 0.03));
            color: var(--text-color);
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            height: 100dvh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
            overflow: hidden;
        }

        @keyframes auroraMove {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            z-index: -1;
            background: linear-gradient(120deg, rgba(80, 227, 194, 0.04), rgba(80, 150, 255, 0.03), rgba(255, 200, 120, 0.02));
            background-size: 300% 300%;
            animation: auroraMove 18s ease-in-out infinite;
            pointer-events: none;
        }

        #game-container {
            width: 100%;
            max-width: 800px;
            aspect-ratio: 4 / 3;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-shrink: 1;
            position: relative;
        }

        canvas {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            width: 100%;
            height: 100%;
            display: block;
        }

        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 100;
            padding: 2rem;
            box-sizing: border-box;
            transition: opacity 0.5s ease-out;
        }

        .splash-title {
            font-size: clamp(2.5rem, 6vw, 4rem);
            font-weight: 700;
            color: var(--accent-color);
            margin-bottom: 1rem;
            text-shadow: 0 0 15px var(--accent-color);
        }

        .splash-subtitle {
            font-size: clamp(1rem, 2.5vw, 1.25rem);
            max-width: 600px;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .splash-link {
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            margin-bottom: 2.5rem;
        }

        .splash-link a {
            color: var(--accent-color);
            font-weight: 600;
            text-decoration: none;
        }

        .play-button {
            font-family: 'Poppins', sans-serif;
            background: var(--accent-color);
            color: var(--primary-bg);
            border: none;
            padding: 1rem 3rem;
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 6px 28px rgba(80, 227, 194, 0.28), 0 2px 6px rgba(0, 0, 0, 0.4) inset;
        }

        .play-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 36px rgba(80, 227, 194, 0.45), 0 2px 6px rgba(0, 0, 0, 0.45) inset;
        }

        .play-button:active {
            transform: scale(0.98);
        }

        #mobile-controls {
            display: none;
            margin-top: 1rem;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        body.touch-enabled #mobile-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            width: 180px;
            justify-items: center;
            align-items: center;
        }

        #mobile-controls button {
            width: 56px;
            height: 56px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(0, 0, 0, 0.06));
            border: 1px solid rgba(255, 255, 255, 0.06);
            color: var(--accent-color);
            font-size: 1.6rem;
            border-radius: 14px;
            font-weight: 700;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
        }


        body.touch-enabled #mobile-controls .up {
            grid-column: 2;
            grid-row: 1;
        }

        body.touch-enabled #mobile-controls .left {
            grid-column: 1;
            grid-row: 2;
        }

        body.touch-enabled #mobile-controls .down {
            grid-column: 2;
            grid-row: 2;
        }

        body.touch-enabled #mobile-controls .right {
            grid-column: 3;
            grid-row: 2;
        }

        @media (max-width: 768px) and (orientation: portrait) {
            body {
                justify-content: space-between;
            }

            #game-container {
                width: 100%;
                height: 70vh;
                max-width: none;
                aspect-ratio: unset;
            }
        }

        #hud-buttons {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
            z-index: 5;
        }

        #hud-buttons button {
            background: rgba(0, 0, 0, 0.45);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 8px;
            padding: 6px 10px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
        }

        #hud-buttons button:hover {
            background: rgba(0, 0, 0, 0.6);
        }
    </style>
</head>

<body>

    <div id="splash-screen">
        <h1 class="splash-title">Newt Crosser</h1>
        <p class="splash-subtitle">Use the Arrow Keys, on-screen controls, or swipe to help the newts safely cross the
            road. Don't get squished!</p>
        <div class="splash-link">
            To learn more about the plight of the newts crossing Alma Bridge Road, visit <a
                href="http://bioblitz.club/newts" target="_blank">bioblitz.club/newts</a>
        </div>
        <div style="display:flex; flex-direction:column; gap:.75rem; max-width:360px; width:100%; align-items:center;">
            <input id="playerNameInput" maxlength="20" placeholder="Your name" aria-label="Player name"
                style="width:100%; padding:.75rem 1rem; border-radius:12px; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.08); color:#fff; font-family:'Poppins',sans-serif; font-size:1rem; outline:none;" />
            <div id="leaderboardSplash"
                style="width:100%; background:rgba(255,255,255,0.07); border:1px solid rgba(255,255,255,0.15); border-radius:12px; padding:1rem; box-sizing:border-box; text-align:left;">
                <div style="font-weight:600; margin-bottom:.5rem; color:var(--accent-color);">Top 5 Scores</div>
                <ol id="leaderboardSplashList"
                    style="margin:0; padding-left:1.2rem; font-size:.9rem; line-height:1.4; opacity:.8;">
                    <li>Loading...</li>
                </ol>
            </div>
        </div>
        <button class="play-button" id="playGameBtn">Play Game</button>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="hud-buttons" aria-label="Game controls">
            <button id="pauseBtn" aria-label="Pause or resume">‚è∏</button>
            <button id="muteBtn" aria-label="Mute or unmute" title="Mute / Unmute">üîä</button>
        </div>
    </div>

    <div id="mobile-controls">
        <button class="up" data-key="ArrowUp">‚ñ≤</button>
        <button class="left" data-key="ArrowLeft">‚óÑ</button>
        <button class="down" data-key="ArrowDown">‚ñº</button>
        <button class="right" data-key="ArrowRight">‚ñ∫</button>
    </div>


    <script>
        const splashScreen = document.getElementById('splash-screen');
        const playGameBtn = document.getElementById('playGameBtn');
        const canvas = document.getElementById("gameCanvas");
        const mobileControls = document.getElementById('mobile-controls');
        const ctx = canvas.getContext("2d");

        let TILE_SIZE = 40;
        let ROAD_TOP_Y, ROAD_BOTTOM_Y, ROAD_CENTER_Y;
        let TRAIL_HEIGHT = 0;
        let score = 0;
        let globalHighScoreForPlayer = 0;
    let rawCrossings = 0;
        let lives = 3;
        let gameOver = false;
        let gameStarted = false;
        let paused = false;
        let newt, vehicles = [], scenery = { trees: [], waitingNewts: [], splats: [], runners: [] };
    let collectibles = [];
    let nextCollectibleSpawnAt = 0;
    const COLLECTIBLE_SPAWN_INTERVAL = 5000;
    let combo = 0;
    let comboMultiplier = 1;
    let playerHasShield = false;
    let trafficSlowUntil = 0;
    let luckActive = false;
    let nextCrossingBonus = 0;
    let achievements = {};
    let notifications = [];
    let dailySeed = 0;
    let dailyBest = 0;
    let muted = false;
    let audioCtx = null;
        let cleaner;
        let playerName = '';
        let leaderboardEntries = [];
        let lastLeaderboardFetch = 0;
        let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;
        let gameTime = 0;
        let hitFlashUntil = 0;
        let lastFrameTime = 0;
        let gameStartTime = 0;
        let lastRunnerSpawnTime = 0;
        let particles = [];
        let raining = false;
        let rainDrops = [];
        let nextRainStart = 0;
        let rainEndTime = 0;
        const RAIN_MIN_INTERVAL = 2500;
        const RAIN_MAX_INTERVAL = 15000;
        const RAIN_MIN_DURATION = 2000;
        const RAIN_MAX_DURATION = 25000;
        const PARTICLE_COUNT = 40;

        const BASE_SPEED_SCALAR = 0.065;
        const RUNNER_SPAWN_INTERVAL = 8000;

        const carColors = ["#B71C1C", "#1A237E", "#004D40", "#E65100", "#4A148C", "#37474F", "#C51162", "#d4ac0d"];
        const vehicleTemplates = {
            car: { width: 2.8, heightMultiplier: 1.5, speedMultiplier: 1.0, draw: drawCar },
            truck: { width: 5.2, heightMultiplier: 3.2, speedMultiplier: 0.75, draw: drawTruck },
            kayakCar: { width: 2.8, heightMultiplier: 1.5, speedMultiplier: 0.9, draw: drawKayakCar },
            motorcycle: { width: 2.0, heightMultiplier: 1.5, speedMultiplier: 1.5, draw: drawMotorcycle },
            bicycle: { width: 1.5, heightMultiplier: 1.5, speedMultiplier: 0.6, draw: drawBicycle },
        };
        const weightedVehicleTypes = ["car", "car", "car", "truck", "kayakCar", "motorcycle", "bicycle", "truck"];

        const GOOGLE_SHEET_WEBAPP_URL = 'https://script.google.com/macros/s/AKfycbzPFFLo3mlmKZahdFkPa8-8rdO2GkSYQaLuL_N1zBwLpf6L9LRX4QtS6hYrksmeRNlS5w/exec';

        async function fetchLeaderboard(force = false) {
            if (!GOOGLE_SHEET_WEBAPP_URL || GOOGLE_SHEET_WEBAPP_URL.startsWith('PUT_')) return;
            if (!force && gameTime - lastLeaderboardFetch < 30000) return;
            try {
                const res = await fetch(GOOGLE_SHEET_WEBAPP_URL + '?t=' + Date.now(), { cache: 'no-store' });
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const data = await res.json();
                leaderboardEntries = Array.isArray(data.top) ? data.top.slice(0, 5) : [];
                if (playerName) {
                    const me = (data.all || []).find(r => r.name === playerName);
                    if (me) globalHighScoreForPlayer = me.score;
                }
                updateSplashLeaderboard();
                lastLeaderboardFetch = gameTime;
            } catch (e) {
            }
        }

        async function submitScore() {
            if (!playerName || score <= 0) return;
            if (!GOOGLE_SHEET_WEBAPP_URL || GOOGLE_SHEET_WEBAPP_URL.startsWith('PUT_')) return;
            try {
                const form = new URLSearchParams({ name: playerName, score: String(score) });
                await fetch(GOOGLE_SHEET_WEBAPP_URL, { method: 'POST', body: form });
                fetchLeaderboard(true);
            } catch (e) {
                console.warn('Submit score failed', e);
            }
        }

        function updateSplashLeaderboard() {
            const listEl = document.getElementById('leaderboardSplashList');
            if (!listEl) return;
            listEl.innerHTML = '';
            if (!leaderboardEntries.length) {
                listEl.innerHTML = '<li>No scores yet</li>';
                return;
            }
            leaderboardEntries.forEach(entry => {
                const li = document.createElement('li');
                li.textContent = `${entry.name}: ${entry.score}`;
                listEl.appendChild(li);
            });
        }

        function setCanvasDimensions() {
            const container = document.getElementById('game-container');
            const { width, height } = container.getBoundingClientRect();
            canvas.width = width;
            canvas.height = height;

            TILE_SIZE = canvas.height / 18;
            ROAD_CENTER_Y = canvas.height / 2;
            ROAD_TOP_Y = ROAD_CENTER_Y - TILE_SIZE * 3;
            ROAD_BOTTOM_Y = ROAD_CENTER_Y + TILE_SIZE * 3;
            TRAIL_HEIGHT = TILE_SIZE * 1.2;
        }

        function resetNewt() {
            newt = {
                width: TILE_SIZE * 0.7,
                height: TILE_SIZE * 0.9,
                x: canvas.width / 2 - (TILE_SIZE * 0.7) / 2,
                y: canvas.height - TILE_SIZE * 2,
                speed: TILE_SIZE,
                rotation: 0,
                targetRotation: 0,
                walkPhase: 0,
            };
        }

        function initCleaner() {
            cleaner = {
                x: -TILE_SIZE * 2,
                y: 0,
                width: TILE_SIZE * 1.2,
                height: TILE_SIZE * 2,
                speed: TILE_SIZE * 0.05,
                isActive: false,
                state: 'idle',
                targetSplat: null,
                cleaningStartTime: 0,
                walkPhase: 0,
                direction: 'right',
                exitSide: 'left'
            };
        }

        function init() {
            setCanvasDimensions();
            score = 0;
            rawCrossings = 0;
            combo = 0;
            comboMultiplier = 1;
            playerHasShield = false;
            lives = 3;
            gameOver = false;
            lastFrameTime = 0;
            resetNewt();
            initCleaner();
            createScenery();
            createVehicles();
            initParticles();
            collectibles = [];
            scheduleNextCollectible(gameTime || performance.now());
            loadAchievements();
            initDaily();
            if (!gameStarted) {
                draw();
            }
            fetchLeaderboard(true);
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (ROAD_TOP_Y - 10),
                    r: 1 + Math.random() * 2,
                    alpha: 0.07 + Math.random() * 0.18,
                    vx: (Math.random() - 0.5) * 10,
                    vy: -5 - Math.random() * 10
                });
            }
        }

        function scheduleNextRain(now) {
            const ref = (typeof now === 'number') ? now : performance.now();
            const interval = Math.max(0, RAIN_MIN_INTERVAL + Math.random() * Math.max(0, RAIN_MAX_INTERVAL - RAIN_MIN_INTERVAL));
            nextRainStart = ref + interval;
        }

        function startRain(now) {
            const ref = (typeof now === 'number') ? now : performance.now();
            raining = true;
            rainDrops = [];
            const dropCount = Math.max(8, Math.floor(canvas.width / 6));
            for (let i = 0; i < dropCount; i++) {
                rainDrops.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    len: 8 + Math.random() * 12,
                    speed: 300 + Math.random() * 400,
                    alpha: 0.35 + Math.random() * 0.5
                });
            }
            const dur = RAIN_MIN_DURATION + Math.random() * Math.max(0, RAIN_MAX_DURATION - RAIN_MIN_DURATION);
            rainEndTime = ref + dur;
            try { console.log('rain started', { rainEndTime, drops: rainDrops.length }); } catch (e) { }
        }

        function stopRain() {
            raining = false;
            rainDrops = [];
            scheduleNextRain(performance.now());
            try { console.log('rain stopped'); } catch (e) { }
        }

        function updateRain(deltaTime) {
            if (!raining) {
                if (gameTime >= nextRainStart) startRain(gameTime);
                return;
            }
            for (const d of rainDrops) {
                d.y += d.speed * deltaTime;
                d.x += (d.speed * 0.05) * deltaTime * (Math.random() - 0.5);
                if (d.y > canvas.height + d.len) {
                    d.y = -d.len - Math.random() * 50;
                    d.x = Math.random() * canvas.width;
                }
            }
            if (gameTime >= rainEndTime) stopRain();
        }

        function drawRain() {
            if (!raining || !rainDrops.length) return;
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(20,30,40,0.06)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'rgba(180,200,230,0.6)';
            ctx.lineWidth = 1;
            for (const d of rainDrops) {
                ctx.globalAlpha = d.alpha;
                ctx.beginPath();
                ctx.moveTo(d.x, d.y);
                ctx.lineTo(d.x - 0.6 * d.len, d.y + d.len);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();
        }

        function startGame() {
            if (gameStarted) return;
            splashScreen.style.opacity = '0';
            splashScreen.style.pointerEvents = 'none';
            init();
            gameStarted = true;
            gameStartTime = Date.now();

            setTimeout(() => {
                spawnRunner(2);
                lastRunnerSpawnTime = performance.now();
            }, 2000);

            scheduleNextRain(performance.now());

            requestAnimationFrame(gameLoop);

            gtag('event', 'start_game', {
                'event_category': 'Game',
                'event_label': 'Play Button Clicked'
            });
        }

        function restartGame() {
            if (!gameOver) return;
            init();
            gameStarted = true;
            gameStartTime = Date.now();
            requestAnimationFrame(gameLoop);
            gtag('event', 'restart_game', {
                'event_category': 'Game',
                'event_label': 'Game Restarted'
            });
        }

        function createScenery() {
            scenery.trees = [];
            scenery.waitingNewts = [];
            scenery.splats = [];
            scenery.runners = [];

            const numWaitingNewts = Math.floor(Math.random() * 5) + 5;
            for (let i = 0; i < numWaitingNewts; i++) {
                scenery.waitingNewts.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (ROAD_TOP_Y - TILE_SIZE) + TILE_SIZE / 2,
                    size: (Math.random() * 0.3 + 0.4) * TILE_SIZE
                });
            }

            for (let i = 0; i < canvas.width / (TILE_SIZE * 4); i++) {
                scenery.trees.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (ROAD_TOP_Y - TILE_SIZE * 2.5) + TILE_SIZE * 2,
                    trunkWidth: (Math.random() * 0.2 + 0.15) * TILE_SIZE,
                    trunkHeight: (Math.random() * 0.6 + 0.4) * TILE_SIZE,
                    canopyLayers: [
                        { dy: 0, radius: (Math.random() * 0.4 + 0.8) * TILE_SIZE, color: '#1e5b3a' },
                        { dy: -TILE_SIZE * 0.3, radius: (Math.random() * 0.4 + 0.7) * TILE_SIZE, color: '#277a4d' },
                        { dy: -TILE_SIZE * 0.5, radius: (Math.random() * 0.3 + 0.6) * TILE_SIZE, color: '#2e8b57' },
                    ]
                });
            }
            scenery.trees.sort((a, b) => a.y - b.y);
        }

        function createVehicles() {
            vehicles = [];
            const lanes = [
                { y: ROAD_CENTER_Y - TILE_SIZE * 1.8, speed: -2.8 },
                { y: ROAD_CENTER_Y + TILE_SIZE * 0.3, speed: 2.2 },
            ];

            const timePlayed = gameStartTime ? (Date.now() - gameStartTime) / 1000 : 0;
            const timeBasedVehicleAddition = Math.min(2, Math.floor(timePlayed / 45));

            lanes.forEach(lane => {
                const baseVehicleCount = 2;
                const numVehicles = Math.floor(Math.random() * 2) + baseVehicleCount + timeBasedVehicleAddition;
                const laneVehicles = [];
                for (let i = 0; i < numVehicles * 4; i++) {
                    const typeKey = weightedVehicleTypes[Math.floor(Math.random() * weightedVehicleTypes.length)];
                    const template = vehicleTemplates[typeKey];
                    const w = TILE_SIZE * template.width;
                    const speedDir = lane.speed > 0 ? 1 : -1;
                    const x = Math.random() * canvas.width * 1.2 + i * (canvas.width / numVehicles * 0.9);
                    const v = {
                        type: typeKey,
                        x,
                        y: lane.y,
                        width: w,
                        height: TILE_SIZE * template.heightMultiplier,
                        baseSpeed: lane.speed,
                        color: carColors[Math.floor(Math.random() * carColors.length)],
                        wheelRot: Math.random() * Math.PI * 2
                    };
                    const timePlayed = gameStartTime ? (Date.now() - gameStartTime) / 1000 : 0;
                    const speedReductionFactor = Math.max(0, 0.20 - (score * 0.02) - (timePlayed / 150) * 0.15);
                    if (speedReductionFactor > 0) {
                        v.baseSpeed *= (1 - speedReductionFactor);
                    }
                    if (v.type === 'bicycle') v.pedalPhase = Math.random() * Math.PI * 2;
                    laneVehicles.push(v);
                }
                laneVehicles.sort((a, b) => a.x - b.x);
                const spaced = [];
                const timePlayed = gameStartTime ? (Date.now() - gameStartTime) / 1000 : 0;
                const baseSpacing = TILE_SIZE * 3.0;
                const minSpacingReduction = Math.min(1.0, (score / 10) + (timePlayed / 180));
                const minSpacing = baseSpacing - (baseSpacing - TILE_SIZE * 1.5) * minSpacingReduction;
                laneVehicles.forEach(v => {
                    const last = spaced[spaced.length - 1];
                    if (!last || v.x - (last.x + last.width) > minSpacing) spaced.push(v);
                });
                spaced.forEach(v => vehicles.push(v));
            });
        }

        const nameInput = document.getElementById('playerNameInput');
        if (nameInput) {
            nameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Tab' ||
                    e.key === 'Shift' ||
                    e.key === 'Control' ||
                    e.key === 'Alt' ||
                    e.key === 'Meta' ||
                    e.key === 'CapsLock') {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                    }
                    return;
                }

                if (e.key === 'Enter') {
                    e.preventDefault();
                    playGameBtn.click();
                }
            });

            nameInput.addEventListener('input', () => {
                playerName = nameInput.value.trim();
            });
        }
        playGameBtn.addEventListener('click', () => {
            playerName = (nameInput && nameInput.value.trim()) || playerName;
            startGame();
        });
        document.addEventListener("keydown", e => {
            if (document.activeElement === nameInput) {
                return;
            }
            handleInput(e.key);
        });
        document.addEventListener('keydown', e => {
            if (e.key === 'm' || e.key === 'M') toggleMute();
        });
        document.addEventListener('keydown', e => {
            if (e.key === 'r' || e.key === 'R') {
                if (raining) stopRain(); else startRain(performance.now());
            }
        });
        document.addEventListener('keydown', e => {
            if (document.activeElement === nameInput) {
                return;
            }
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });

        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            document.body.classList.add('touch-enabled');
        }

        mobileControls.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                handleInput(e.target.dataset.key);
            }
        });
        const pauseBtn = document.getElementById('pauseBtn');
        pauseBtn.addEventListener('click', () => togglePause());
    const muteBtn = document.getElementById('muteBtn');
    muteBtn.addEventListener('click', () => toggleMute());

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            if (gameOver) {
                restartGame();
                return;
            }
            touchStartX = e.changedTouches[0].clientX;
            touchStartY = e.changedTouches[0].clientY;
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            touchEndX = e.changedTouches[0].clientX;
            touchEndY = e.changedTouches[0].clientY;
            handleSwipe();
        }, { passive: false });


        window.addEventListener('load', () => {
            if (nameInput) {
                setTimeout(() => nameInput.focus(), 500);
            }
        });

        window.addEventListener('resize', () => {
            setTimeout(() => {
                const wasRunning = gameStarted && !gameOver;
                const wasGameOver = gameOver;

                init();

                if (wasRunning) {
                    gameStarted = true;
                    requestAnimationFrame(gameLoop);
                } else if (wasGameOver) {
                    gameStarted = true;
                    gameOver = true;
                    draw();
                }
            }, 250);
        });


        function handleSwipe() {
            if (gameOver) return;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            const swipeThreshold = 30;

            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > swipeThreshold) {
                    handleInput(dx > 0 ? 'ArrowRight' : 'ArrowLeft');
                }
            } else {
                if (Math.abs(dy) > swipeThreshold) {
                    handleInput(dy > 0 ? 'ArrowDown' : 'ArrowUp');
                }
            }
        }

        function handleInput(key) {
            if (gameOver) {
                if (key === "Enter") {
                    restartGame();
                }
                return;
            }
            if (paused) return;

            if (!newt) return;

            if (!gameStarted) {
                startGame();
                return;
            }

            switch (key) {
                case "ArrowUp": newt.y -= newt.speed; newt.targetRotation = 0; break;
                case "ArrowDown": if (newt.y < canvas.height - newt.height * 2) newt.y += newt.speed; newt.targetRotation = Math.PI; break;
                case "ArrowLeft": if (newt.x > 0) newt.x -= newt.speed; newt.targetRotation = -Math.PI / 2; break;
                case "ArrowRight": if (newt.x < canvas.width - newt.width) newt.x += newt.speed; newt.targetRotation = Math.PI / 2; break;
            }
        }

        function togglePause() {
            if (!gameStarted || gameOver) return;
            paused = !paused;
            const btn = document.getElementById('pauseBtn');
            if (btn) btn.textContent = paused ? '‚ñ∂' : '‚è∏';
        }

        function update(deltaTime) {
            if (gameOver) return;
            if (gameStarted && newt) {
                newt.walkPhase = (gameTime / 200) % (Math.PI * 2);
            }

            if (gameStarted && gameTime - lastRunnerSpawnTime > RUNNER_SPAWN_INTERVAL) {
                spawnRunner(1 + Math.floor(Math.random() * 3));
                lastRunnerSpawnTime = gameTime;
            }

            updateRunners(deltaTime);
            updateParticles(deltaTime);
            updateRain(deltaTime);
            updateCollectibles();
            if (newt) checkCollectibleCollisions();
            if (newt) {
                let dy = newt.targetRotation - newt.rotation;
                if (Math.abs(dy) > Math.PI) dy = dy < 0 ? dy + 2 * Math.PI : dy - 2 * Math.PI;
                newt.rotation += dy * 0.2;
            }

            const timePlayed = (Date.now() - gameStartTime) / 1000;
            const scoreDifficulty = 0.7 + score * 0.05 + Math.pow(score, 1.5) * 0.005;
            const timeDifficulty = Math.min(1.0, timePlayed / 120) * 0.8;
            const difficultyFactor = Math.min(3.5, scoreDifficulty + timeDifficulty);

            vehicles.forEach(v => {
                const speedPxPerSec = v.baseSpeed * BASE_SPEED_SCALAR * canvas.width * difficultyFactor;
                v.x += speedPxPerSec * deltaTime;
                if (v.type !== 'bicycle') {
                    const wheelRadius = v.height * 0.16;
                    v.wheelRot = (v.wheelRot + (speedPxPerSec * deltaTime) / Math.max(1, wheelRadius)) % (Math.PI * 2);
                }

                if (v.type === 'bicycle') {
                    const pedalSpeed = 0.2;
                    v.pedalPhase = (v.pedalPhase + pedalSpeed) % (Math.PI * 2);
                }
                if (v.baseSpeed > 0 && v.x > canvas.width + v.width) v.x = -v.width;
                else if (v.baseSpeed < 0 && v.x < -v.width * 2) v.x = canvas.width + v.width;
            });

            vehicles.forEach(v => {
                if (newt && newt.x < v.x + v.width && newt.x + newt.width > v.x && newt.y < v.y + v.height && newt.y + newt.height > v.y) {
                    handleCollision();
                }
            });

            if (newt && newt.y < ROAD_TOP_Y) {
                handleSuccess();
            }

            updateCleaner();
        }

        function updateParticles(deltaTime) {
            for (const p of particles) {
                p.x += p.vx * deltaTime * 0.6;
                p.y += p.vy * deltaTime * 0.6;
                if (p.y + p.r < 0 || p.x < -50 || p.x > canvas.width + 50) {
                    p.x = Math.random() * canvas.width;
                    p.y = ROAD_TOP_Y - 5 - Math.random() * 30;
                    p.vx = (Math.random() - 0.5) * 6;
                    p.vy = -5 - Math.random() * 6;
                }
            }
        }

        function activateCleaner(splat) {
            cleaner.isActive = true;
            cleaner.targetSplat = splat;
            cleaner.state = 'entering';

            const startOnLeft = splat.x < canvas.width / 2;
            cleaner.x = startOnLeft ? -cleaner.width * 2 : canvas.width + cleaner.width * 2;
            cleaner.y = ROAD_BOTTOM_Y + TILE_SIZE;
            cleaner.direction = startOnLeft ? 'right' : 'left';
        }

        function updateCleaner() {
            if (!cleaner.isActive) return;

            cleaner.walkPhase = (gameTime / 150) % (Math.PI * 2);
            const cleaningDuration = 1500;

            const isExiting = cleaner.state === 'exiting';
            const targetX = isExiting ? (cleaner.exitSide === 'left' ? -cleaner.width * 2 : canvas.width + cleaner.width) : cleaner.targetSplat.x - cleaner.width / 2;
            const targetY = isExiting ? ROAD_BOTTOM_Y + TILE_SIZE : cleaner.targetSplat.y - cleaner.height / 2;

            const dx = targetX - cleaner.x;
            const dy = targetY - cleaner.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (cleaner.state === 'cleaning') {
                if (gameTime - cleaner.cleaningStartTime > cleaningDuration) {
                    scenery.splats = scenery.splats.filter(s => s.id !== cleaner.targetSplat.id);
                    cleaner.targetSplat = null;
                    cleaner.state = 'exiting';
                    cleaner.exitSide = cleaner.x < canvas.width / 2 ? 'right' : 'left';
                }
                return;
            }

            if (distance < cleaner.speed * 1.5) {
                if (!isExiting) {
                    cleaner.state = 'cleaning';
                    cleaner.cleaningStartTime = gameTime;
                } else {
                    cleaner.isActive = false;
                    cleaner.state = 'idle';
                    if (scenery.splats.length > 0) {
                        activateCleaner(scenery.splats[0]);
                    }
                }
                return;
            }

            let canMove = true;
            let moveX = 0;
            let moveY = 0;

            if (Math.abs(dy) > cleaner.speed) {
                moveY = Math.sign(dy) * cleaner.speed;
            } else {
                moveX = Math.sign(dx) * cleaner.speed;
                cleaner.direction = moveX > 0 ? 'right' : 'left';

                if (cleaner.y > ROAD_TOP_Y && cleaner.y < ROAD_BOTTOM_Y) {
                    const safetyBuffer = TILE_SIZE * 4;
                    for (const v of vehicles) {
                        if (Math.abs(v.y - cleaner.y) < TILE_SIZE * 1.5) {
                            const cleanerFront = cleaner.x + (cleaner.direction === 'right' ? cleaner.width : 0);

                            if (cleaner.direction === 'right' && v.baseSpeed < 0 && v.x + v.width > cleanerFront && v.x < cleanerFront + safetyBuffer) {
                                canMove = false;
                                break;
                            }
                            if (cleaner.direction === 'left' && v.baseSpeed > 0 && v.x < cleanerFront && v.x + v.width > cleanerFront - safetyBuffer) {
                                canMove = false;
                                break;
                            }
                        }
                    }
                }
            }

            if (canMove) {
                cleaner.x += moveX;
                cleaner.y += moveY;
            }
        }

        function handleCollision() {
            if (!newt) return;

            if (playerHasShield) {
                // absorb one collision
                playerHasShield = false;
                addNotification('Shield saved you!');
                unlockAchievement('shield_save', 'Safety First: Shield absorbed a hit');
                playSound('shield');
                hitFlashUntil = gameTime + 120;
                return; // no death
            }

            hitFlashUntil = gameTime + 250;

            const newSplat = {
                x: newt.x + newt.width / 2,
                y: newt.y + newt.height / 2,
                creationTime: gameTime,
                maxRadius: TILE_SIZE * 0.8,
                id: Date.now() + Math.random()
            };
            scenery.splats.push(newSplat);

            if (!cleaner.isActive) {
                activateCleaner(newSplat);
            }

            newt = null;
            lives--;
            combo = 0;
            comboMultiplier = 1;
            playSound('hit');

            if (lives <= 0) {
                gameOver = true;

                gtag('event', 'game_over', {
                    'event_category': 'Game',
                    'event_label': 'Player Lost',
                    'value': score
                });

                submitScore();
                fetchLeaderboard(true);
                updateDailyBest();
            } else {
                setTimeout(resetNewt, 500);
            }
        }

        function handleSuccess() {
            rawCrossings++;
            combo++;
            comboMultiplier = 1 + Math.floor(combo / 3) * 0.5; // 1.0,1.0,1.0 -> 1.5 -> 2.0 etc
            const award = 1 * comboMultiplier;
            score = Math.round(score + award);
            playSound('cross');
            if (combo === 3) unlockAchievement('combo3', 'Hot Streak: 3 crossings combo');
            if (combo === 6) unlockAchievement('combo6', 'On Fire: 6 crossings combo');
            if (rawCrossings === 1) unlockAchievement('first_cross', 'First Crossing');
            if (rawCrossings === 10) unlockAchievement('ten_cross', 'Ten Crossings');
            if (raining) unlockAchievement('rain_cross', 'Storm Runner: Crossed in rain');
            resetNewt();

            gtag('event', 'newt_crossed', {
                'event_category': 'Game',
                'event_label': 'Successful Crossing',
                'value': score
            });
        }

        function spawnRunner(count = 1) {
            for (let i = 0; i < count; i++) {
                const onTopSide = Math.random() < 0.5;
                const baseY = onTopSide ? (ROAD_TOP_Y - TRAIL_HEIGHT / 2) : (ROAD_BOTTOM_Y + TRAIL_HEIGHT / 2);
                const y = baseY + (Math.random() - 0.5) * (TRAIL_HEIGHT * 0.6);

                const movingRight = Math.random() < 0.5;
                const x = movingRight ? -TILE_SIZE * (1 + Math.random() * 3) : canvas.width + TILE_SIZE * (1 + Math.random() * 3);

                const speed = TILE_SIZE * (1.0 + Math.random() * 0.8) * (0.9 + Math.random() * 0.6);
                const colors = ["#e53935", "#1e88e5", "#43a047", "#fb8c00", "#8e24aa", "#01579b"];
                const shirtColor = colors[Math.floor(Math.random() * colors.length)];
                const shortsColor = colors[Math.floor(Math.random() * colors.length)];

                const skinTones = ['#e0ac69', '#c68642', '#8d5524', '#f1c27d', '#ffdbac'];
                const hairColors = ['#2c1e0e', '#4a3520', '#5a3825', '#70482b', '#a56b46', '#dbb471', '#090806'];
                const skinTone = skinTones[Math.floor(Math.random() * skinTones.length)];
                const hairColor = hairColors[Math.floor(Math.random() * hairColors.length)];

                scenery.runners.push({
                    x,
                    y,
                    movingRight,
                    onTopSide,
                    speed: movingRight ? speed : -speed,
                    runPhase: Math.random() * Math.PI * 2,
                    runSpeed: 1.0 + Math.random() * 1.2,
                    skinTone,
                    hairColor,
                    outfit: {
                        shirt: shirtColor,
                        shorts: shortsColor
                    }
                });
            }
        }

        function updateRunners(deltaTime) {
            if (paused) return;

            scenery.runners.forEach(runner => {
                runner.x += runner.speed * deltaTime;
                runner.runPhase = (runner.runPhase + deltaTime * runner.runSpeed * 7) % (Math.PI * 2);
            });

            scenery.runners = scenery.runners.filter(runner => {
                if (runner.movingRight) {
                    return runner.x < canvas.width + TILE_SIZE * 2;
                } else {
                    return runner.x > -TILE_SIZE * 2;
                }
            });
        }

        function drawRunner(runner) {
            const x = runner.x;
            const y = runner.y;
            const size = TILE_SIZE;
            const facing = runner.movingRight ? 1 : -1;
            const bobHeight = Math.sin(runner.runPhase * 2) * (size * 0.08);
            const skinTone = runner.skinTone || '#e0ac69';

            ctx.save();
            ctx.translate(x, y + bobHeight);
            const thighLen = size * 0.28;
            const shinLen = size * 0.28;
            const legW = Math.max(2, size * 0.06);
            const leftOffsetX = -size * 0.12;
            const rightOffsetX = size * 0.12;
            const rp = runner.runPhase;

            const drawLeg = (offsetX, phaseOffset) => {
                const phase = rp + phaseOffset;
                const hipAngle = Math.sin(phase) * 0.9;
                const kneeBendFactor = Math.max(0, Math.sin(phase + Math.PI * 0.25));
                const kneeAngle = -kneeBendFactor * 1.2;

                ctx.save();
                ctx.translate(offsetX, 0);
                ctx.rotate(hipAngle);
                ctx.fillStyle = skinTone;
                ctx.fillRect(-legW / 2, 0, legW, thighLen);
                ctx.translate(0, thighLen);
                ctx.rotate(kneeAngle);
                ctx.fillRect(-legW / 2, 0, legW, shinLen);
                ctx.translate(0, shinLen);
                const footTilt = (Math.sin(phase + Math.PI * 0.5) * 0.6);
                ctx.rotate(footTilt);
                ctx.fillRect(-legW * 1.1, 0, legW * 2.2, legW * 0.9);
                ctx.restore();
            };

            drawLeg(leftOffsetX, 0);
            drawLeg(rightOffsetX, Math.PI);

            ctx.fillStyle = runner.outfit.shirt;
            ctx.fillRect(-size * 0.15, -size * 0.5, size * 0.3, size * 0.3);
            ctx.fillStyle = runner.outfit.shorts;
            ctx.fillRect(-size * 0.15, -size * 0.2, size * 0.3, size * 0.2);

            const shoulderY = -size * 0.45;
            const shoulderOffsetX = size * 0.18;
            const hipLeft = Math.sin(rp) * 0.9;
            const hipRight = Math.sin(rp + Math.PI) * 0.9;
            const armAngleLeft = -hipLeft * 0.8;
            const armAngleRight = -hipRight * 0.8;

            const upperArmLen = size * 0.18;
            const forearmLen = size * 0.18;
            const armW = Math.max(2, size * 0.055);

            ctx.save();
            ctx.translate(-shoulderOffsetX, shoulderY);
            ctx.rotate(armAngleLeft);
            ctx.fillStyle = skinTone;
            ctx.fillRect(-armW / 2, 0, armW, upperArmLen);
            ctx.translate(0, upperArmLen);
            const elbowBend = Math.max(-1, Math.min(1, -Math.sin(rp) * 0.6));
            ctx.rotate(elbowBend);
            ctx.fillRect(-armW / 2, 0, armW, forearmLen);
            ctx.restore();

            ctx.save();
            ctx.translate(shoulderOffsetX, shoulderY);
            ctx.rotate(armAngleRight);
            ctx.fillStyle = skinTone;
            ctx.fillRect(-armW / 2, 0, armW, upperArmLen);
            ctx.translate(0, upperArmLen);
            const elbowBendR = Math.max(-1, Math.min(1, -Math.sin(rp + Math.PI) * 0.6));
            ctx.rotate(elbowBendR);
            ctx.fillRect(-armW / 2, 0, armW, forearmLen);
            ctx.restore();

            ctx.fillStyle = skinTone;
            ctx.beginPath();
            ctx.arc(0, -size * 0.6, size * 0.1, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawReflections();
            drawParticles();
            drawCollectibles();

            scenery.runners.forEach(drawRunner);

            scenery.splats.forEach(drawSplat);
            drawHumanCleaner();

            vehicles.forEach(v => {
                const template = vehicleTemplates[v.type];
                template.draw(v);
            });

            if (gameStarted && !gameOver && newt) {
                drawNewt(newt.x, newt.y, newt.width, newt.height);
            }

            drawRain();

            drawVignette();

            drawUI();
            drawNotifications();

            if (gameOver) {
                drawGameOver();
            }
        }

        function drawParticles() {
            if (!particles || !particles.length) return;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (const p of particles) {
                ctx.fillStyle = `rgba(200,230,255,${p.alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawNewt(x, y, w, h) {
            ctx.save();
            ctx.translate(x + w / 2, y + h / 2);
            ctx.rotate(newt.rotation);

            const walkCycle = Math.sin(newt.walkPhase);
            const legShift = walkCycle * (w * 0.08);
            const legColor = "#af7d1c";
            const legLength = w * 0.3;
            const legThickness = h * 0.15;
            const bodySide = w * 0.35;

            ctx.fillStyle = legColor;
            ctx.fillRect(-bodySide - legLength + legShift, -h * 0.2, legLength, legThickness);
            ctx.fillRect(bodySide + legShift, h * 0.2 - legThickness, legLength, legThickness);
            ctx.fillRect(bodySide - legShift, -h * 0.2, legLength, legThickness);
            ctx.fillRect(-bodySide - legLength - legShift, h * 0.2 - legThickness, legLength, legThickness);

            ctx.fillStyle = "#cf8e23";
            ctx.beginPath();
            ctx.ellipse(0, h * 0.6, w * 0.2, h * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#e59f28";
            ctx.beginPath();
            ctx.ellipse(0, 0, w * 0.45, h * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "#f5d47a";
            ctx.beginPath();
            ctx.ellipse(0, 0, w * 0.35, h * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#e59f28";
            ctx.beginPath();
            ctx.ellipse(0, -h * 0.4, w * 0.4, h * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(-w * 0.15, -h * 0.45, w * 0.05, 0, Math.PI * 2);
            ctx.arc(w * 0.15, -h * 0.45, w * 0.05, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawHumanCleaner() {
            if (!cleaner.isActive) return;

            ctx.save();
            ctx.translate(cleaner.x, cleaner.y);

            const w = cleaner.width;
            const h = cleaner.height;
            const walkCycle = Math.sin(cleaner.walkPhase);
            const bob = Math.sin(cleaner.walkPhase * 2) * (TILE_SIZE * 0.05);

            ctx.strokeStyle = "#a0522d";
            ctx.lineWidth = w * 0.1;
            ctx.beginPath();
            ctx.moveTo(w * 0.5, h * 0.5 + bob);
            const mopAngle = cleaner.direction === 'right' ? Math.PI / 4 : (3 * Math.PI) / 4;
            const mopEndX = w * 0.5 + Math.cos(mopAngle) * w;
            const mopEndY = h * 0.5 + bob + Math.sin(mopAngle) * w;
            ctx.lineTo(mopEndX, mopEndY);
            ctx.stroke();

            if (cleaner.state === 'cleaning') {
                const cleaningProgress = (gameTime - cleaner.cleaningStartTime) / 1000;
                const mopHeadX = cleaner.targetSplat.x - cleaner.x + Math.sin(cleaningProgress * Math.PI * 6) * (w * 0.5);
                const mopHeadY = cleaner.targetSplat.y - cleaner.y;
                ctx.fillStyle = "#e6e6e6";
                ctx.beginPath();
                ctx.ellipse(mopHeadX, mopHeadY, w * 0.4, w * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = "#2c3e50";
            const legShift = walkCycle * (w * 0.2);
            ctx.fillRect(w * 0.3 - legShift, h * 0.6 + bob, w * 0.2, h * 0.4);
            ctx.fillRect(w * 0.5 + legShift, h * 0.6 + bob, w * 0.2, h * 0.4);

            ctx.fillStyle = "#f39c12";
            ctx.fillRect(w * 0.15, h * 0.2 + bob, w * 0.7, h * 0.4);
            ctx.fillStyle = "#f39c12";
            ctx.fillRect(w * 0.15, h * 0.2 + bob, w * 0.7, h * 0.4);
            const vestX = w * 0.15;
            const vestY = h * 0.2 + bob;
            const vestW = w * 0.7;
            const vestH = h * 0.4;
            ctx.save();
            ctx.beginPath();
            ctx.rect(vestX, vestY, vestW, vestH);
            ctx.clip();
            ctx.translate(vestX + vestW * 0.5, vestY + vestH * 0.5);
            const scaleX = Math.min(1, (vestW * 0.9) / (TILE_SIZE * 2.6));
            const scaleY = Math.min(1, (vestH * 0.5) / (TILE_SIZE * 0.6));
            ctx.transform(scaleX, -0.08, 0, scaleY, 0, 0);
            ctx.fillStyle = '#2c3e50';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `700 ${Math.max(6, Math.round(TILE_SIZE * 0.12))}px 'Poppins'`;
            ctx.fillText('newt patrol', 0, 0);
            ctx.restore();
            ctx.fillStyle = "#bdc3c7";
            ctx.fillRect(w * 0.1, h * 0.4 + bob, w * 0.8, h * 0.08);

            ctx.fillStyle = "#f1c40f";
            ctx.beginPath();
            ctx.arc(w * 0.5, h * 0.15 + bob, w * 0.25, Math.PI, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#e67e22";
            ctx.beginPath();
            ctx.arc(w * 0.5, h * 0.15 + bob, w * 0.2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawSplat(splat) {
            const age = gameTime - splat.creationTime;
            const maxLife = 3000;
            const opacity = 1 - (age / maxLife);

            ctx.save();
            ctx.fillStyle = `rgba(107, 142, 35, 0.7)`;
            ctx.beginPath();
            ctx.ellipse(splat.x, splat.y, splat.maxRadius, splat.maxRadius * 0.7, Math.PI / 4, 0, Math.PI * 2);
            ctx.ellipse(splat.x + 5, splat.y - 5, splat.maxRadius * 0.5, splat.maxRadius * 0.8, Math.PI / 2, 0, Math.PI * 2);
            ctx.ellipse(splat.x - 5, splat.y + 5, splat.maxRadius * 0.9, splat.maxRadius * 0.6, -Math.PI / 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawWaitingNewt(x, y, size) {
            ctx.save();
            ctx.fillStyle = "#d95f26";
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.ellipse(x, y, size * 0.4, size * 0.5, 0, 0, Math.PI * 2);
            ctx.ellipse(x, y - size * 0.4, size * 0.3, size * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
            ctx.restore();
        }

        function drawBackground() {
            ctx.fillStyle = "#277a4d";
            ctx.fillRect(0, 0, canvas.width, ROAD_TOP_Y);

            ctx.fillStyle = '#7a4f2b';
            ctx.fillRect(0, ROAD_TOP_Y - TRAIL_HEIGHT, canvas.width, TRAIL_HEIGHT);

            scenery.waitingNewts.forEach(n => drawWaitingNewt(n.x, n.y, n.size));
            scenery.trees.forEach(tree => {
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--trunk-color');
                ctx.fillRect(tree.x - tree.trunkWidth / 2, tree.y - tree.trunkHeight, tree.trunkWidth, tree.trunkHeight);
                tree.canopyLayers.forEach(layer => {
                    ctx.fillStyle = layer.color;
                    ctx.beginPath();
                    ctx.arc(tree.x, tree.y - tree.trunkHeight + layer.dy, layer.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
            });

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--road-color');
            ctx.fillRect(0, ROAD_TOP_Y, canvas.width, ROAD_BOTTOM_Y - ROAD_TOP_Y);

            ctx.strokeStyle = 'rgba(255,255,255,0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, ROAD_TOP_Y + 2);
            ctx.lineTo(canvas.width, ROAD_TOP_Y + 2);
            ctx.moveTo(0, ROAD_BOTTOM_Y - 2);
            ctx.lineTo(canvas.width, ROAD_BOTTOM_Y - 2);
            ctx.stroke();

            ctx.font = `bold ${TILE_SIZE * 0.8}px 'Poppins'`;
            ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Alma Bridge Road", canvas.width / 2, ROAD_CENTER_Y);

            ctx.strokeStyle = "#ffd700";
            ctx.lineWidth = 6;
            ctx.setLineDash([TILE_SIZE * 0.8, TILE_SIZE * 0.9]);
            const dashOffset = (gameTime / 12) % (TILE_SIZE * 1.7);
            ctx.lineDashOffset = -dashOffset;
            ctx.beginPath();
            ctx.moveTo(0, ROAD_CENTER_Y);
            ctx.lineTo(canvas.width, ROAD_CENTER_Y);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.lineDashOffset = 0;

            const waterY = ROAD_BOTTOM_Y;
            const waterHeight = canvas.height - waterY;
            const grad = ctx.createLinearGradient(0, waterY, 0, canvas.height);
            grad.addColorStop(0, "#3b6fa5");
            grad.addColorStop(1, "#2a4d75");
            ctx.fillStyle = grad;
            ctx.fillRect(0, waterY, canvas.width, waterHeight);

            ctx.fillStyle = '#7a4f2b';
            ctx.fillRect(0, ROAD_BOTTOM_Y, canvas.width, TRAIL_HEIGHT);

            ctx.font = `bold ${TILE_SIZE * 0.8}px 'Poppins'`;
            ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Lexington Reservoir", canvas.width / 2, waterY + waterHeight / 2);
        }

        function drawCar(vehicle) {
            const { x, y, width: w, height: h, color, baseSpeed: speed, wheelRot } = vehicle;
            ctx.save();
            ctx.translate(x, y);
            drawMotionStreak(speed, w, h);
            ctx.fillStyle = 'rgba(0,0,0,0.18)';
            ctx.beginPath();
            ctx.ellipse(w * 0.5, h * 0.95, w * 0.6, h * 0.18, 0, 0, Math.PI * 2);
            ctx.fill();

            const bodyGrad = ctx.createLinearGradient(0, 0, 0, h);
            bodyGrad.addColorStop(0, lighten(color, 0.28));
            bodyGrad.addColorStop(0.45, color);
            bodyGrad.addColorStop(1, darken(color, 0.3));
            ctx.fillStyle = bodyGrad;

            const radius = Math.min(w, h) * 0.14;
            ctx.beginPath();
            ctx.moveTo(radius, h * 0.6);
            ctx.lineTo(w - radius, h * 0.6);
            ctx.quadraticCurveTo(w, h * 0.6, w, h * 0.5);
            ctx.lineTo(w, h * 0.28);
            ctx.quadraticCurveTo(w, h * 0.18, w - radius, h * 0.18);
            ctx.lineTo(radius, h * 0.18);
            ctx.quadraticCurveTo(0, h * 0.18, 0, h * 0.28);
            ctx.lineTo(0, h * 0.5);
            ctx.quadraticCurveTo(0, h * 0.6, radius, h * 0.6);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = darken(color, 0.06);
            ctx.beginPath();
            ctx.moveTo(radius, h * 0.62);
            ctx.lineTo(w - radius, h * 0.62);
            ctx.lineTo(w - radius, h * 0.88);
            ctx.lineTo(radius, h * 0.88);
            ctx.closePath();
            ctx.fill();

            const winH = h * 0.22;
            const winY = h * 0.22;
            const windowGrad = ctx.createLinearGradient(0, winY, 0, winY + winH);
            windowGrad.addColorStop(0, 'rgba(200,230,255,0.95)');
            windowGrad.addColorStop(1, 'rgba(120,150,190,0.55)');
            ctx.fillStyle = windowGrad;
            ctx.beginPath();
            ctx.moveTo(w * 0.18, winY + 2);
            ctx.lineTo(w * 0.82, winY + 2);
            ctx.lineTo(w * 0.72, winY + winH - 2);
            ctx.lineTo(w * 0.28, winY + winH - 2);
            ctx.closePath();
            ctx.fill();

            drawWheel(w * 0.22, h * 0.88, h * 0.18, wheelRot);
            drawWheel(w * 0.78, h * 0.88, h * 0.18, wheelRot);

            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            const plateW = w * 0.14;
            ctx.fillRect(w * 0.5 - plateW / 2, h * 0.66, plateW, h * 0.06);

            const frontLightX = speed > 0 ? w - w * 0.08 : w * 0.08;
            const rearLightX = speed > 0 ? w * 0.08 : w - w * 0.08;
            drawHeadlight(frontLightX, h * 0.52, h * 0.10);
            drawTaillight(rearLightX, h * 0.52, h * 0.10);

            ctx.restore();
        }

        function drawTruck(vehicle) {
            const { x, y, width: w, height: h, color, baseSpeed: speed, wheelRot } = vehicle;
            ctx.save();
            ctx.translate(x, y);
            drawMotionStreak(speed, w, h);

            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(w * 0.5, h * 0.94, w * 0.7, h * 0.14, 0, 0, Math.PI * 2);
            ctx.fill();

            const trailerWidth = w * 0.6;
            const cabWidth = w * 0.28;
            const trailerX = speed > 0 ? 0 : cabWidth + w * 0.02;
            const cabX = speed > 0 ? trailerWidth + w * 0.02 : 0;

            const trailerGrad = ctx.createLinearGradient(trailerX, 0, trailerX + trailerWidth, 0);
            trailerGrad.addColorStop(0, darken('#dfe5e8', 0.0));
            trailerGrad.addColorStop(0.5, '#d7dde1');
            trailerGrad.addColorStop(1, darken('#dfe5e8', 0.05));
            ctx.fillStyle = trailerGrad;
            ctx.beginPath();
            ctx.roundRect(trailerX, h * 0.14, trailerWidth, h * 0.72, h * 0.04);
            ctx.fill();

            ctx.fillStyle = darken(color, 0.06);
            ctx.beginPath();
            ctx.roundRect(cabX, h * 0.18, cabWidth, h * 0.64, h * 0.08);
            ctx.fill();

            const wy = h * 0.92;
            drawWheel(trailerX + trailerWidth * 0.22, wy, h * 0.14, wheelRot);
            drawWheel(trailerX + trailerWidth * 0.5, wy, h * 0.14, wheelRot + 0.5);
            drawWheel(trailerX + trailerWidth * 0.78, wy, h * 0.14, wheelRot + 1.0);
            drawWheel(cabX + cabWidth * 0.55, wy, h * 0.16, wheelRot);

            const cabWindowGrad = ctx.createLinearGradient(cabX, h * 0.2, cabX, h * 0.5);
            cabWindowGrad.addColorStop(0, 'rgba(200,230,255,0.95)');
            cabWindowGrad.addColorStop(1, 'rgba(120,150,190,0.6)');
            ctx.fillStyle = cabWindowGrad;
            ctx.beginPath();
            ctx.moveTo(cabX + cabWidth * 0.12, h * 0.28);
            ctx.lineTo(cabX + cabWidth * 0.88, h * 0.28);
            ctx.lineTo(cabX + cabWidth * 0.7, h * 0.48);
            ctx.lineTo(cabX + cabWidth * 0.3, h * 0.48);
            ctx.closePath();
            ctx.fill();

            const trailerBackX = trailerX + trailerWidth;
            drawHeadlight(cabX + cabWidth * 0.95, h * 0.56, h * 0.16);
            drawTaillight(trailerBackX - 4, h * 0.56, h * 0.14);

            ctx.restore();
        }

        function drawHeadlight(x, y, size) {
            const glowSize = size * 2.5;
            const lightGradient = ctx.createRadialGradient(x, y, size * 0.2, x, y, glowSize);
            lightGradient.addColorStop(0, 'rgba(255, 255, 224, 1)');
            lightGradient.addColorStop(0.3, 'rgba(255, 255, 224, 0.8)');
            lightGradient.addColorStop(1, 'rgba(255, 255, 224, 0)');
            ctx.fillStyle = lightGradient;
            ctx.fillRect(x - glowSize, y - glowSize, glowSize * 2, glowSize * 2);
        }

        function drawTaillight(x, y, size) {
            const glowSize = size * 2;
            const lightGradient = ctx.createRadialGradient(x, y, size * 0.3, x, y, glowSize);
            lightGradient.addColorStop(0, 'rgba(255, 20, 20, 1)');
            lightGradient.addColorStop(0.5, 'rgba(200, 0, 0, 0.5)');
            lightGradient.addColorStop(1, 'rgba(150, 0, 0, 0)');
            ctx.fillStyle = lightGradient;
            ctx.fillRect(x - glowSize, y - glowSize, glowSize * 2, glowSize * 2);
        }

        function drawKayakCar(vehicle) {
            drawCar(vehicle);
            const { x, y, width: w, height: h } = vehicle;
            ctx.fillStyle = "#d95f26";
            ctx.beginPath();
            ctx.ellipse(x + w / 2, y + h * 0.05, w * 0.4, h * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMotorcycle(vehicle) {
            const { x, y, width: w, height: h, color, baseSpeed, wheelRot } = vehicle;
            ctx.save();
            ctx.translate(x, y);

            drawMotionStreak(baseSpeed, w, h);

            ctx.fillStyle = 'rgba(0,0,0,0.18)';
            ctx.beginPath();
            ctx.ellipse(w / 2, h * 0.88, w / 2, h * 0.12, 0, 0, Math.PI * 2);
            ctx.fill();

            drawWheel(w * 0.15, h * 0.78, h * 0.2, wheelRot);
            drawWheel(w * 0.85, h * 0.78, h * 0.2, wheelRot);

            const frameGrad = ctx.createLinearGradient(0, h * 0.3, 0, h * 0.8);
            frameGrad.addColorStop(0, lighten(color, 0.1));
            frameGrad.addColorStop(1, darken(color, 0.1));
            ctx.fillStyle = frameGrad;
            ctx.beginPath();
            ctx.moveTo(w * 0.15, h * 0.75);
            ctx.lineTo(w * 0.42, h * 0.4);
            ctx.lineTo(w * 0.85, h * 0.75);
            ctx.closePath();
            ctx.fill();

            const riderCenterX = w * 0.5;
            const riderBodyY = h * 0.05;
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(riderCenterX - w * 0.1, riderBodyY + h * 0.3, w * 0.2, h * 0.4);
            ctx.fillStyle = '#B71C1C';
            ctx.beginPath();
            ctx.moveTo(riderCenterX - w * 0.2, riderBodyY + h * 0.5);
            ctx.lineTo(riderCenterX - w * 0.1, riderBodyY);
            ctx.lineTo(riderCenterX + w * 0.2, riderBodyY);
            ctx.lineTo(riderCenterX + w * 0.1, riderBodyY + h * 0.5);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#B71C1C';
            ctx.lineWidth = w * 0.15;
            ctx.beginPath();
            const handlebarX = baseSpeed > 0 ? riderCenterX + w * 0.35 : riderCenterX - w * 0.35;
            ctx.moveTo(riderCenterX, riderBodyY + h * 0.1);
            ctx.lineTo(handlebarX, h * 0.4);
            ctx.stroke();

            ctx.fillStyle = '#37474F';
            ctx.beginPath();
            ctx.arc(riderCenterX, riderBodyY, h * 0.18, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(230, 245, 255, 0.8)';
            const visorX = baseSpeed > 0 ? riderCenterX + h * 0.05 : riderCenterX - h * 0.15;
            ctx.fillRect(visorX, riderBodyY - h * 0.08, h * 0.1, h * 0.12);

            const headX = baseSpeed > 0 ? w - 2 : 2;
            drawHeadlight(headX, h * 0.55, h * 0.13);

            ctx.restore();
        }

        function drawWheel(cx, cy, r, rot = 0) {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(rot);
            ctx.translate(-cx, -cy);
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(cx, cy, r * 0.45, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#bbb';
            ctx.beginPath();
            ctx.arc(cx, cy, r * 0.18, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = r * 0.1;
            for (let i = 0; i < 4; i++) {
                const a = (Math.PI / 2) * i;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(a) * r * 0.85, cy + Math.sin(a) * r * 0.85);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawMotionStreak(speed, w, h) {
            const strength = Math.min(1, Math.abs(speed) * 0.6);
            if (strength <= 0.01) return;
            ctx.save();
            const streakW = w * 0.6 * strength;
            const grad = ctx.createLinearGradient(0, 0, streakW, 0);
            if (speed > 0) {
                grad.addColorStop(0, 'rgba(255,255,255,0.0)');
                grad.addColorStop(1, 'rgba(255,255,255,0.08)');
                ctx.fillStyle = grad;
                ctx.fillRect(-streakW, h * 0.35, streakW, h * 0.4);
            } else {
                grad.addColorStop(0, 'rgba(255,255,255,0.08)');
                grad.addColorStop(1, 'rgba(255,255,255,0.0)');
                ctx.fillStyle = grad;
                ctx.fillRect(w, h * 0.35, streakW, h * 0.4);
            }
            ctx.restore();
        }

        function lighten(hex, amt) {
            const { r, g, b } = hexToRgb(hex);
            return rgbToHex(
                Math.min(255, Math.round(r + 255 * amt)),
                Math.min(255, Math.round(g + 255 * amt)),
                Math.min(255, Math.round(b + 255 * amt))
            );
        }
        function darken(hex, amt) {
            const { r, g, b } = hexToRgb(hex);
            return rgbToHex(
                Math.max(0, Math.round(r * (1 - amt))),
                Math.max(0, Math.round(g * (1 - amt))),
                Math.max(0, Math.round(b * (1 - amt)))
            );
        }
        function hexToRgb(hex) {
            const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (!m) return { r: 200, g: 200, b: 200 };
            return { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) };
        }
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
        }

        if (typeof CanvasRenderingContext2D !== 'undefined' && !CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (typeof r === 'number') r = { tl: r, tr: r, br: r, bl: r };
                else r = Object.assign({ tl: 0, tr: 0, br: 0, bl: 0 }, r);
                this.beginPath();
                this.moveTo(x + r.tl, y);
                this.lineTo(x + w - r.tr, y);
                this.quadraticCurveTo(x + w, y, x + w, y + r.tr);
                this.lineTo(x + w, y + h - r.br);
                this.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
                this.lineTo(x + r.bl, y + h);
                this.quadraticCurveTo(x, y + h, x, y + h - r.bl);
                this.lineTo(x, y + r.tl);
                this.quadraticCurveTo(x, y, x + r.tl, y);
                this.closePath();
            };
        }

        function drawBicycle(vehicle) {
            const { x, y, width: w, height: h, color, baseSpeed, pedalPhase } = vehicle;
            ctx.save();
            ctx.translate(x, y);

            ctx.strokeStyle = '#555'; ctx.lineWidth = w * 0.08;
            ctx.beginPath();
            ctx.arc(w * 0.15, h * 0.8, h * 0.18, 0, Math.PI * 2);
            ctx.arc(w * 0.85, h * 0.8, h * 0.18, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = color; ctx.lineWidth = w * 0.06;
            ctx.beginPath();
            ctx.moveTo(w * 0.15, h * 0.8);
            ctx.lineTo(w * 0.5, h * 0.4);
            ctx.lineTo(w * 0.85, h * 0.8);
            ctx.stroke();

            const bodyBob = Math.sin(pedalPhase * 2) * (h * 0.05);
            const riderX = w * 0.5;
            const riderY = h * 0.15 + bodyBob;

            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(riderX - w * 0.15, riderY, w * 0.3, h * 0.4);

            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(riderX, riderY, h * 0.15, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#e0aA77';
            ctx.lineWidth = w * 0.08;
            ctx.beginPath();
            const handlebarX = baseSpeed > 0 ? riderX + w * 0.25 : riderX - w * 0.25;
            ctx.moveTo(riderX, riderY + h * 0.2);
            ctx.lineTo(handlebarX, h * 0.5);
            ctx.stroke();

            const hipY = riderY + h * 0.4;
            const crankX = w * 0.5;
            const crankY = h * 0.8;
            const pedalRadius = h * 0.18;

            const pedal1X = crankX + pedalRadius * Math.cos(pedalPhase);
            const pedal1Y = crankY + pedalRadius * Math.sin(pedalPhase);
            ctx.beginPath();
            ctx.moveTo(riderX, hipY);
            ctx.lineTo(pedal1X, pedal1Y);
            ctx.stroke();

            const pedal2X = crankX + pedalRadius * Math.cos(pedalPhase + Math.PI);
            const pedal2Y = crankY + pedalRadius * Math.sin(pedalPhase + Math.PI);
            ctx.beginPath();
            ctx.moveTo(riderX, hipY);
            ctx.lineTo(pedal2X, pedal2Y);
            ctx.stroke();


            ctx.restore();
        }


        function drawUI() {
            ctx.save();
            ctx.font = `600 ${TILE_SIZE * 0.5}px 'Poppins'`;

            ctx.textAlign = "left";
            ctx.fillStyle = "rgba(0,0,0,0.62)";
            ctx.roundRect(15, 15, TILE_SIZE * 3.5, TILE_SIZE * 1, 10);
            ctx.fill();
            ctx.fillStyle = "white";
            ctx.fillText(`Score: ${score}`, 25, 15 + TILE_SIZE * 0.65);

            // combo & multiplier (bottom-left overlay of score box)
            ctx.font = `400 ${TILE_SIZE * 0.35}px 'Poppins'`;
            ctx.fillStyle = combo > 1 ? (combo >= 6 ? '#ffbf00' : '#50e3c2') : 'rgba(255,255,255,0.6)';
            ctx.fillText(`x${comboMultiplier.toFixed(1)} Combo:${combo}`, 25, 15 + TILE_SIZE * 1.0);
            ctx.font = `600 ${TILE_SIZE * 0.5}px 'Poppins'`;

            ctx.textAlign = "right";
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.roundRect(canvas.width - TILE_SIZE * 3.5 - 15, 15, TILE_SIZE * 3.5, TILE_SIZE * 1, 10);
            ctx.fill();
            ctx.fillStyle = "white";
            ctx.fillText(`Lives: ${lives}`, canvas.width - 25, 15 + TILE_SIZE * 0.65);

            ctx.textAlign = "center";
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.roundRect(canvas.width / 2 - TILE_SIZE * 4, 15, TILE_SIZE * 8, TILE_SIZE * 1, 10);
            ctx.fill();
            ctx.fillStyle = "white";
            const topGlobal = leaderboardEntries.length ? leaderboardEntries[0].score : 0;
            const centerText = playerName ? `${playerName} Best: ${globalHighScoreForPlayer || 0}  |  Top Score: ${topGlobal}` : `Top Score: ${topGlobal}`;
            ctx.fillText(centerText, canvas.width / 2, 15 + TILE_SIZE * 0.65);

            // daily best small label
            ctx.font = `400 ${TILE_SIZE * 0.3}px 'Poppins'`;
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.fillText(`Daily Best: ${dailyBest}`, canvas.width / 2, 15 + TILE_SIZE * 1.05);
            ctx.font = `600 ${TILE_SIZE * 0.5}px 'Poppins'`;

            // shield indicator top-left corner of lives box
            if (playerHasShield) {
                ctx.save();
                ctx.strokeStyle = '#50e3c2';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(canvas.width - TILE_SIZE * 0.9, 15 + TILE_SIZE * 0.5, TILE_SIZE * 0.3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.font = `700 ${TILE_SIZE * 0.35}px 'Poppins'`;
                ctx.fillStyle = '#50e3c2';
                ctx.fillText('S', canvas.width - TILE_SIZE * 0.9, 15 + TILE_SIZE * 0.6);
                ctx.restore();
            }

            ctx.restore();

            if (gameTime < hitFlashUntil) {
                ctx.save();
                ctx.fillStyle = 'rgba(255,0,0,0.18)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            if (paused && !gameOver) {
                drawPauseOverlay();
            }
        }

        function drawReflections() {
            if (!raining) return;
            const reflectHeight = TILE_SIZE * 1.2;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.06;
            for (let i = 0; i < vehicles.length; i++) {
                const v = vehicles[i];
                const rx = v.x + v.width * 0.5;
                const ry = v.y + v.height * 0.95;
                const grad = ctx.createLinearGradient(0, ry, 0, ry + reflectHeight);
                grad.addColorStop(0, 'rgba(200,220,255,0.5)');
                grad.addColorStop(1, 'rgba(200,220,255,0.0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.ellipse(rx, ry + reflectHeight * 0.2, v.width * 0.6, reflectHeight * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            if (newt) {
                const rx = newt.x + newt.width * 0.5;
                const ry = newt.y + newt.height * 0.95;
                const grad = ctx.createLinearGradient(0, ry, 0, ry + reflectHeight);
                grad.addColorStop(0, 'rgba(255,220,200,0.32)');
                grad.addColorStop(1, 'rgba(255,220,200,0.0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.ellipse(rx, ry + reflectHeight * 0.2, newt.width * 0.6, reflectHeight * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawVignette() {
            const vAlpha = 0.25;
            ctx.save();
            const grad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, Math.min(canvas.width, canvas.height) * 0.25, canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * 0.9);
            grad.addColorStop(0, `rgba(0,0,0,0)`);
            grad.addColorStop(1, `rgba(0,0,0,${vAlpha})`);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
        }

        function drawGameOver() {
            ctx.fillStyle = "rgba(26, 26, 42, 0.85)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--danger-color');
            ctx.textAlign = "center";
            ctx.font = `bold ${TILE_SIZE * 1.5}px 'Poppins'`;
            ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - TILE_SIZE * 1.5);

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-color');
            ctx.font = `600 ${TILE_SIZE * 0.8}px 'Poppins'`;
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 - TILE_SIZE * 0.2);
            ctx.fillStyle = '#fff';
            ctx.font = `400 ${TILE_SIZE * 0.55}px 'Poppins'`;
            ctx.fillText(`Raw Crossings: ${rawCrossings}`, canvas.width / 2, canvas.height / 2 + TILE_SIZE * 0.4);

            if (playerName) {
                ctx.fillStyle = "#f0f0f0";
                ctx.font = `400 ${TILE_SIZE * 0.6}px 'Poppins'`;
                ctx.fillText(`${playerName} Best: ${globalHighScoreForPlayer || score}`, canvas.width / 2, canvas.height / 2 + TILE_SIZE * 0.6);
            }

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-color');
            ctx.font = `600 ${TILE_SIZE * 0.8}px 'Poppins'`;
            ctx.fillText('Top 5 Scores', canvas.width / 2, canvas.height / 2 + TILE_SIZE * 1.8);
            ctx.font = `400 ${TILE_SIZE * 0.5}px 'Poppins'`;
            leaderboardEntries.forEach((e, i) => {
                ctx.fillStyle = '#fff';
                const medal = i === 0 ? 'ü•á ' : i === 1 ? 'ü•à ' : i === 2 ? 'ü•â ' : '';
                ctx.fillText(`${medal}${e.name}: ${e.score}`, canvas.width / 2, canvas.height / 2 + TILE_SIZE * (2.4 + i * 0.6));
            });
            ctx.fillStyle = "white";
            ctx.font = `400 ${TILE_SIZE * 0.5}px 'Poppins'`;
            ctx.fillText("Tap or Press Enter to Restart", canvas.width / 2, canvas.height / 2 + TILE_SIZE * (2.5 + leaderboardEntries.length * 0.6));
            // show unlocked summary small
            const unlockedCount = Object.values(achievements).filter(a => a.unlocked).length;
            ctx.font = `400 ${TILE_SIZE * 0.4}px 'Poppins'`;
            ctx.fillText(`${unlockedCount} Achievements Unlocked Today`, canvas.width / 2, canvas.height / 2 + TILE_SIZE * (3.1 + leaderboardEntries.length * 0.6));
        }


        function gameLoop(timestamp) {
            if (!lastFrameTime) {
                lastFrameTime = timestamp;
            }
            let deltaTime = (timestamp - lastFrameTime) / 1000;
            lastFrameTime = timestamp;
            gameTime = timestamp;

            if (gameOver) {
                draw();
                return;
            }
            if (paused) {
                draw();
                requestAnimationFrame(gameLoop);
                return;
            }

            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function drawPauseOverlay() {
            ctx.fillStyle = 'rgba(26, 26, 42, 0.6)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-color');
            ctx.textAlign = 'center';
            ctx.font = `bold ${TILE_SIZE * 1.3}px 'Poppins'`;
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - TILE_SIZE * 0.5);
            ctx.fillStyle = '#fff';
            ctx.font = `400 ${TILE_SIZE * 0.6}px 'Poppins'`;
            ctx.fillText('Press P or tap ‚ñ∂ to resume', canvas.width / 2, canvas.height / 2 + TILE_SIZE * 0.6);
        }

        init();

        function scheduleNextCollectible(now) {
            const ref = typeof now === 'number' ? now : performance.now();
            nextCollectibleSpawnAt = ref + (COLLECTIBLE_SPAWN_INTERVAL * (0.6 + Math.random() * 0.8));
        }

        function spawnCollectible(type) {
            const weighted = ['firefly','firefly','firefly','shield','worm','slug','clover','egg','firefly'];
            const cType = type || weighted[Math.floor(Math.random()*weighted.length)];
            const y = ROAD_BOTTOM_Y + Math.random() * (canvas.height - ROAD_BOTTOM_Y - TILE_SIZE * 2);
            const x = Math.random() * (canvas.width - TILE_SIZE) + TILE_SIZE / 2;
            collectibles.push({ id: Date.now() + Math.random(), x, y, type: cType, created: gameTime, pulse: Math.random() * Math.PI * 2 });
        }

    function updateCollectibles() {
            if (gameTime >= nextCollectibleSpawnAt && collectibles.length < 5 && !paused) {
                spawnCollectible();
                scheduleNextCollectible(gameTime);
            }
            collectibles = collectibles.filter(c => gameTime - c.created < 20000);
            collectibles.forEach(c => c.pulse += 0.05);
        }

        function drawCollectibles() {
            if (!collectibles.length) return;
            collectibles.forEach(c => {
                ctx.save();
                const size = TILE_SIZE * (c.type === 'shield' ? 0.45 : 0.35);
                const pulseScale = 1 + Math.sin(c.pulse * 3) * 0.15;
                ctx.translate(c.x, c.y);
                if (c.type === 'firefly') {
                    const grad = ctx.createRadialGradient(0, 0, size * 0.1, 0, 0, size * 1.4);
                    grad.addColorStop(0, 'rgba(255, 240, 120, 0.95)');
                    grad.addColorStop(0.4, 'rgba(255, 200, 50, 0.6)');
                    grad.addColorStop(1, 'rgba(255, 160, 0, 0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * pulseScale, 0, Math.PI * 2);
                    ctx.fill();
                } else if (c.type === 'shield') {
                    ctx.strokeStyle = '#50e3c2';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.85;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * pulseScale, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 0.25;
                    ctx.fillStyle = '#50e3c2';
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.7 * pulseScale, 0, Math.PI * 2);
                    ctx.fill();
                } else if (c.type === 'worm') {
                    ctx.fillStyle = '#b87333';
                    ctx.beginPath();
                    for (let i=0;i<6;i++){ ctx.ellipse(-size*0.6 + i*size*0.25, Math.sin(c.pulse*4+i)*size*0.15, size*0.18, size*0.22, 0, 0, Math.PI*2);} 
                    ctx.fill();
                } else if (c.type === 'slug') {
                    ctx.fillStyle = '#6c9a3a';
                    ctx.beginPath();
                    ctx.ellipse(0,0,size*0.9,size*0.45,0,0,Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle='#88c452';
                    ctx.beginPath();
                    ctx.ellipse(-size*0.2,-size*0.1,size*0.25,size*0.18,0,0,Math.PI*2);
                    ctx.fill();
                } else if (c.type === 'clover') {
                    ctx.fillStyle = '#2e8b57';
                    for (let i=0;i<4;i++){ ctx.beginPath(); ctx.ellipse(Math.cos(i*Math.PI/2)*size*0.35, Math.sin(i*Math.PI/2)*size*0.35, size*0.3, size*0.25, 0,0,Math.PI*2); ctx.fill(); }
                } else if (c.type === 'egg') {
                    ctx.fillStyle = '#f2e6c9';
                    ctx.beginPath();
                    ctx.ellipse(0,0,size*0.4,size*0.55,0,0,Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();
            });
        }

        function checkCollectibleCollisions() {
            const n = newt;
            if (!n) return;
            collectibles = collectibles.filter(c => {
                const dx = Math.abs(c.x - (n.x + n.width / 2));
                const dy = Math.abs(c.y - (n.y + n.height / 2));
                if (dx < n.width * 0.7 && dy < n.height * 0.7) {
                    if (c.type === 'firefly') {
                        const add = 2 * comboMultiplier;
                        score = Math.round(score + add);
                        addNotification(`+${add} firefly`);
                        playSound('collect');
                        unlockAchievement('collect1', 'First Firefly');
                    } else if (c.type === 'shield') {
                        playerHasShield = true;
                        addNotification('Shield Acquired');
                        unlockAchievement('shield1', 'Protective Slime: Got a shield');
                        playSound('shield');
                    } else if (c.type === 'worm') {
                        if (lives < 5) { lives++; addNotification('Life +1'); playSound('collect'); }
                        unlockAchievement('worm1','Found a Worm');
                    } else if (c.type === 'slug') {
                        trafficSlowUntil = gameTime + 6000;
                        addNotification('Traffic Slowed');
                        unlockAchievement('slug1','Slug Slowdown');
                        playSound('collect');
                    } else if (c.type === 'clover') {
                        luckActive = true;
                        addNotification('Luck Active');
                        unlockAchievement('clover1','Lucky Clover');
                        playSound('collect');
                    } else if (c.type === 'egg') {
                        const add2 = Math.round(5 * comboMultiplier);
                        score += add2;
                        nextCrossingBonus += 2;
                        addNotification(`Egg +${add2}`);
                        unlockAchievement('egg1','Newt Egg Bonus');
                        playSound('collect');
                    }
                    return false;
                }
                return true;
            });
        }

        /* Achievements */
        function loadAchievements() {
            try { achievements = JSON.parse(localStorage.getItem('newt_achievements') || '{}'); } catch (e) { achievements = {}; }
        }
        function saveAchievements() {
            try { localStorage.setItem('newt_achievements', JSON.stringify(achievements)); } catch (e) { }
        }
        function unlockAchievement(key, label) {
            if (!achievements[key]) achievements[key] = { unlocked: false, label };
            if (!achievements[key].unlocked) {
                achievements[key].unlocked = true;
                achievements[key].label = label;
                addNotification(label, '#50e3c2');
                saveAchievements();
            }
        }

        function addNotification(text, color) {
            notifications.push({ id: Date.now() + Math.random(), text, color: color || '#ffd760', created: gameTime });
            if (notifications.length > 5) notifications.shift();
        }
        function drawNotifications() {
            const life = 4000;
            const baseY = TILE_SIZE * 2.2;
            notifications = notifications.filter(n => gameTime - n.created < life);
            notifications.forEach((n, i) => {
                const age = gameTime - n.created;
                const alpha = age < 300 ? age / 300 : (age > life - 400 ? (life - age) / 400 : 1);
                const y = baseY + i * (TILE_SIZE * 0.55);
                ctx.save();
                ctx.globalAlpha = Math.max(0, alpha);
                ctx.font = `600 ${TILE_SIZE * 0.45}px 'Poppins'`;
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(0,0,0,0.55)';
                const w = ctx.measureText(n.text).width + 30;
                ctx.roundRect(canvas.width / 2 - w / 2, y - TILE_SIZE * 0.45, w, TILE_SIZE * 0.8, 12);
                ctx.fill();
                ctx.fillStyle = n.color;
                ctx.fillText(n.text, canvas.width / 2, y);
                ctx.restore();
            });
        }

        function initDaily() {
            const dateStr = new Date().toISOString().slice(0, 10);
            dailySeed = hashString(dateStr) & 0xffffffff;
            try { dailyBest = parseInt(localStorage.getItem('newt_daily_' + dateStr) || '0', 10); } catch (e) { dailyBest = 0; }
        }
        function updateDailyBest() {
            const dateStr = new Date().toISOString().slice(0, 10);
            if (score > dailyBest) {
                dailyBest = score;
                try { localStorage.setItem('newt_daily_' + dateStr, String(dailyBest)); } catch (e) { }
                addNotification('New Daily Best!');
            }
        }
        function hashString(str) { let h = 2166136261; for (let i = 0; i < str.length; i++) { h ^= str.charCodeAt(i); h = Math.imul(h, 16777619); } return h >>> 0; }

        const baseCreateVehicles = createVehicles;
        createVehicles = function () {
            vehicles = [];
            const lanes = [
                { y: ROAD_CENTER_Y - TILE_SIZE * 1.8, speed: -2.8 },
                { y: ROAD_CENTER_Y + TILE_SIZE * 0.3, speed: 2.2 },
            ];
            if (rawCrossings >= 5 || score >= 20) {
                lanes.push({ y: ROAD_CENTER_Y - TILE_SIZE * 0.5, speed: 3.3 });
            }
            if (rawCrossings >= 12 || score >= 45) {
                lanes.push({ y: ROAD_CENTER_Y + TILE_SIZE * 1.6, speed: -3.6 });
            }
            lanes.forEach(lane => {
                const baseVehicleCount = 2;
                const numVehicles = Math.floor(Math.random() * 2) + baseVehicleCount + Math.min(2, Math.floor(rawCrossings / 8));
                const laneVehicles = [];
                for (let i = 0; i < numVehicles * 4; i++) {
                    const typeKey = weightedVehicleTypes[Math.floor(Math.random() * weightedVehicleTypes.length)];
                    const template = vehicleTemplates[typeKey];
                    const w = TILE_SIZE * template.width;
                    const x = Math.random() * canvas.width * 1.2 + i * (canvas.width / numVehicles * 0.9);
                    const v = { type: typeKey, x, y: lane.y, width: w, height: TILE_SIZE * template.heightMultiplier, baseSpeed: lane.speed, color: carColors[Math.floor(Math.random() * carColors.length)], wheelRot: Math.random() * Math.PI * 2 };
                    if (v.type === 'bicycle') v.pedalPhase = Math.random() * Math.PI * 2;
                    laneVehicles.push(v);
                }
                laneVehicles.sort((a, b) => a.x - b.x);
                const spaced = [];
                const baseSpacing = TILE_SIZE * 3.0;
                const minSpacingReduction = Math.min(1.0, (score / 10) + (rawCrossings / 12));
                const minSpacing = baseSpacing - (baseSpacing - TILE_SIZE * 1.5) * minSpacingReduction;
                laneVehicles.forEach(v => { const last = spaced[spaced.length - 1]; if (!last || v.x - (last.x + last.width) > minSpacing) spaced.push(v); });
                spaced.forEach(v => vehicles.push(v));
            });
        };

        function ensureAudio() { if (!audioCtx && !muted) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { } } }
        function playSound(type) {
            if (muted) return;
            ensureAudio();
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.connect(g).connect(audioCtx.destination);
            if (type === 'cross') { o.frequency.value = 660; } else if (type === 'collect') { o.frequency.value = 880; } else if (type === 'hit') { o.frequency.value = 90; } else if (type === 'shield') { o.frequency.value = 400; }
            o.type = type === 'hit' ? 'sawtooth' : 'sine';
            g.gain.setValueAtTime(0.001, now);
            g.gain.exponentialRampToValueAtTime(0.2, now + 0.01);
            g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
            o.start(now);
            o.stop(now + 0.4);
        }
        function toggleMute() { muted = !muted; const btn = document.getElementById('muteBtn'); if (btn) btn.textContent = muted ? 'üîá' : 'üîä'; if (!muted) ensureAudio(); }

    addNotification('Welcome! Collect items!', '#50e3c2');
        unlockAchievement('session_start', 'Session Started');

    </script>
</body>

</html>
