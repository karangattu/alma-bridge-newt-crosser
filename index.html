<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Alma Bridge Newt Crosser</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LZ4SSN195H"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-LZ4SSN195H');
    </script>

    <style>
        :root {
            --primary-bg: #1a1a2a;
            --secondary-bg: #2a2a3a;
            --text-color: #f0f0f0;
            --accent-color: #50e3c2;
            --road-color: #6c6c7c;
            --water-color: #3b6fa5;
            --forest-color: #2e8b57;
            --danger-color: #e35050;
            --trunk-color: #5d4037;
        }

        body {
            background-color: var(--primary-bg);
            color: var(--text-color);
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            height: 100dvh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
            overflow: hidden;
        }

        #game-container {
            width: 100%;
            max-width: 800px;
            aspect-ratio: 4 / 3;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-shrink: 1;
            position: relative;
        }

        canvas {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            width: 100%;
            height: 100%;
            display: block;
        }

        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 100;
            padding: 2rem;
            box-sizing: border-box;
            transition: opacity 0.5s ease-out;
        }

        .splash-title {
            font-size: clamp(2.5rem, 6vw, 4rem);
            font-weight: 700;
            color: var(--accent-color);
            margin-bottom: 1rem;
            text-shadow: 0 0 15px var(--accent-color);
        }

        .splash-subtitle {
            font-size: clamp(1rem, 2.5vw, 1.25rem);
            max-width: 600px;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .splash-link {
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            margin-bottom: 2.5rem;
        }

        .splash-link a {
            color: var(--accent-color);
            font-weight: 600;
            text-decoration: none;
        }

        .play-button {
            font-family: 'Poppins', sans-serif;
            background: var(--accent-color);
            color: var(--primary-bg);
            border: none;
            padding: 1rem 3rem;
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 5px 20px rgba(80, 227, 194, 0.4);
        }

        .play-button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(80, 227, 194, 0.6);
        }

        #mobile-controls {
            display: none;
            margin-top: 1rem;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        body.touch-enabled #mobile-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            width: 180px;
            justify-items: center;
            align-items: center;
        }

        #mobile-controls button {
            width: 50px;
            height: 50px;
            background: var(--secondary-bg);
            border: 2px solid var(--accent-color);
            color: var(--accent-color);
            font-size: 1.5rem;
            border-radius: 50%;
            font-weight: bold;
            cursor: pointer;
        }

        body.touch-enabled #mobile-controls .up {
            grid-column: 2;
            grid-row: 1;
        }

        body.touch-enabled #mobile-controls .left {
            grid-column: 1;
            grid-row: 2;
        }

        body.touch-enabled #mobile-controls .down {
            grid-column: 2;
            grid-row: 2;
        }

        body.touch-enabled #mobile-controls .right {
            grid-column: 3;
            grid-row: 2;
        }

        @media (max-width: 768px) and (orientation: portrait) {
            body {
                justify-content: space-between;
            }

            #game-container {
                width: 100%;
                height: 70vh;
                max-width: none;
                aspect-ratio: unset;
            }
        }

        /* HUD buttons (e.g., Pause) */
        #hud-buttons {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
            z-index: 5;
        }

        #hud-buttons button {
            background: rgba(0, 0, 0, 0.45);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 8px;
            padding: 6px 10px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
        }

        #hud-buttons button:hover {
            background: rgba(0, 0, 0, 0.6);
        }
    </style>
</head>

<body>

    <div id="splash-screen">
        <h1 class="splash-title">Newt Crosser</h1>
        <p class="splash-subtitle">Use the Arrow Keys, on-screen controls, or swipe to help the newts safely cross the
            road. Don't get squished!</p>
        <div class="splash-link">
            To learn more about the plight of the newts crossing Alma Bridge Road, visit <a
                href="http://bioblitz.club/newts" target="_blank">bioblitz.club/newts</a>
        </div>
        <div style="display:flex; flex-direction:column; gap:.75rem; max-width:360px; width:100%; align-items:center;">
            <input id="playerNameInput" maxlength="20" placeholder="Your name" aria-label="Player name"
                style="width:100%; padding:.75rem 1rem; border-radius:12px; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.08); color:#fff; font-family:'Poppins',sans-serif; font-size:1rem; outline:none;" />
            <div id="leaderboardSplash"
                style="width:100%; background:rgba(255,255,255,0.07); border:1px solid rgba(255,255,255,0.15); border-radius:12px; padding:1rem; box-sizing:border-box; text-align:left;">
                <div style="font-weight:600; margin-bottom:.5rem; color:var(--accent-color);">Top 5 Global Scores</div>
                <ol id="leaderboardSplashList"
                    style="margin:0; padding-left:1.2rem; font-size:.9rem; line-height:1.4; opacity:.8;">
                    <li>Loading...</li>
                </ol>
            </div>
        </div>
        <button class="play-button" id="playGameBtn">Play Game</button>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="hud-buttons" aria-label="Game controls">
            <button id="pauseBtn" aria-label="Pause or resume">⏸</button>
        </div>
    </div>

    <div id="mobile-controls">
        <button class="up" data-key="ArrowUp">▲</button>
        <button class="left" data-key="ArrowLeft">◄</button>
        <button class="down" data-key="ArrowDown">▼</button>
        <button class="right" data-key="ArrowRight">►</button>
    </div>


    <script>
        const splashScreen = document.getElementById('splash-screen');
        const playGameBtn = document.getElementById('playGameBtn');
        const canvas = document.getElementById("gameCanvas");
        const mobileControls = document.getElementById('mobile-controls');
        const ctx = canvas.getContext("2d");

        let TILE_SIZE = 40;
        let ROAD_TOP_Y, ROAD_BOTTOM_Y, ROAD_CENTER_Y;
        let score = 0; // local high score removed; using only global leaderboard now
        let globalHighScoreForPlayer = 0;
        let lives = 3;
        let gameOver = false;
        let gameStarted = false;
        let paused = false;
        let newt, vehicles = [], scenery = { trees: [], waitingNewts: [], splats: [] };
        let cleaner;
        let playerName = '';
        let leaderboardEntries = [];
        let lastLeaderboardFetch = 0;
        let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;
        let gameTime = 0;
        let hitFlashUntil = 0;
        let lastFrameTime = 0;

        const BASE_SPEED_SCALAR = 0.065;

        const carColors = ["#B71C1C", "#1A237E", "#004D40", "#E65100", "#4A148C", "#37474F", "#C51162", "#d4ac0d"];
        const vehicleTemplates = {
            car: { width: 2.8, heightMultiplier: 1.5, speedMultiplier: 1.0, draw: drawCar },
            truck: { width: 5.2, heightMultiplier: 3.2, speedMultiplier: 0.75, draw: drawTruck },
            kayakCar: { width: 2.8, heightMultiplier: 1.5, speedMultiplier: 0.9, draw: drawKayakCar },
            motorcycle: { width: 2.0, heightMultiplier: 1.5, speedMultiplier: 1.5, draw: drawMotorcycle },
            bicycle: { width: 1.5, heightMultiplier: 1.5, speedMultiplier: 0.6, draw: drawBicycle },
        };
        const weightedVehicleTypes = ["car", "car", "car", "truck", "kayakCar", "motorcycle", "bicycle", "truck"];

        const GOOGLE_SHEET_WEBAPP_URL = 'https://script.google.com/macros/s/AKfycbzPFFLo3mlmKZahdFkPa8-8rdO2GkSYQaLuL_N1zBwLpf6L9LRX4QtS6hYrksmeRNlS5w/exec';

        async function fetchLeaderboard(force = false) {
            if (!GOOGLE_SHEET_WEBAPP_URL || GOOGLE_SHEET_WEBAPP_URL.startsWith('PUT_')) return; // not configured
            if (!force && gameTime - lastLeaderboardFetch < 30000) return; // throttle to 30s
            try {
                const res = await fetch(GOOGLE_SHEET_WEBAPP_URL + '?t=' + Date.now(), { cache: 'no-store' });
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const data = await res.json();
                leaderboardEntries = Array.isArray(data.top) ? data.top.slice(0, 5) : [];
                if (playerName) {
                    const me = (data.all || []).find(r => r.name === playerName);
                    if (me) globalHighScoreForPlayer = me.score;
                }
                updateSplashLeaderboard();
                lastLeaderboardFetch = gameTime;
            } catch (e) {
                // silent fail
            }
        }

        async function submitScore() {
            if (!playerName || score <= 0) return;
            if (!GOOGLE_SHEET_WEBAPP_URL || GOOGLE_SHEET_WEBAPP_URL.startsWith('PUT_')) return;
            try {
                const form = new URLSearchParams({ name: playerName, score: String(score) });
                await fetch(GOOGLE_SHEET_WEBAPP_URL, { method: 'POST', body: form });
                fetchLeaderboard(true);
            } catch (e) {
                console.warn('Submit score failed', e);
            }
        }

        function updateSplashLeaderboard() {
            const listEl = document.getElementById('leaderboardSplashList');
            if (!listEl) return;
            listEl.innerHTML = '';
            if (!leaderboardEntries.length) {
                listEl.innerHTML = '<li>No scores yet</li>';
                return;
            }
            leaderboardEntries.forEach(entry => {
                const li = document.createElement('li');
                li.textContent = `${entry.name}: ${entry.score}`;
                listEl.appendChild(li);
            });
        }

        function setCanvasDimensions() {
            const container = document.getElementById('game-container');
            const { width, height } = container.getBoundingClientRect();
            canvas.width = width;
            canvas.height = height;

            TILE_SIZE = canvas.height / 18;
            ROAD_CENTER_Y = canvas.height / 2;
            ROAD_TOP_Y = ROAD_CENTER_Y - TILE_SIZE * 3;
            ROAD_BOTTOM_Y = ROAD_CENTER_Y + TILE_SIZE * 3;
        }

        function resetNewt() {
            newt = {
                width: TILE_SIZE * 0.7,
                height: TILE_SIZE * 0.9,
                x: canvas.width / 2 - (TILE_SIZE * 0.7) / 2,
                y: canvas.height - TILE_SIZE * 2,
                speed: TILE_SIZE,
                rotation: 0,
                targetRotation: 0,
                walkPhase: 0,
            };
        }

        function initCleaner() {
            cleaner = {
                x: -TILE_SIZE * 2,
                y: 0,
                width: TILE_SIZE * 1.2,
                height: TILE_SIZE * 2,
                speed: TILE_SIZE * 0.05,
                isActive: false,
                state: 'idle',
                targetSplat: null,
                cleaningStartTime: 0,
                walkPhase: 0,
                direction: 'right',
                exitSide: 'left'
            };
        }

        function init() {
            setCanvasDimensions();
            score = 0;
            lives = 3;
            gameOver = false;
            lastFrameTime = 0;
            resetNewt();
            initCleaner();
            createScenery();
            createVehicles();
            if (!gameStarted) {
                draw();
            }
            fetchLeaderboard(true);
        }

        function startGame() {
            if (gameStarted) return;
            splashScreen.style.opacity = '0';
            splashScreen.style.pointerEvents = 'none';
            init();
            gameStarted = true;
            requestAnimationFrame(gameLoop);

            gtag('event', 'start_game', {
                'event_category': 'Game',
                'event_label': 'Play Button Clicked'
            });
        }

        function restartGame() {
            if (!gameOver) return;
            init();
            gameStarted = true;
            requestAnimationFrame(gameLoop);
            gtag('event', 'restart_game', {
                'event_category': 'Game',
                'event_label': 'Game Restarted'
            });
        }

        function createScenery() {
            scenery.trees = [];
            scenery.waitingNewts = [];
            scenery.splats = [];

            const numWaitingNewts = Math.floor(Math.random() * 5) + 5;
            for (let i = 0; i < numWaitingNewts; i++) {
                scenery.waitingNewts.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (ROAD_TOP_Y - TILE_SIZE) + TILE_SIZE / 2,
                    size: (Math.random() * 0.3 + 0.4) * TILE_SIZE
                });
            }

            for (let i = 0; i < canvas.width / (TILE_SIZE * 4); i++) {
                scenery.trees.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (ROAD_TOP_Y - TILE_SIZE * 2.5) + TILE_SIZE * 2,
                    trunkWidth: (Math.random() * 0.2 + 0.15) * TILE_SIZE,
                    trunkHeight: (Math.random() * 0.6 + 0.4) * TILE_SIZE,
                    canopyLayers: [
                        { dy: 0, radius: (Math.random() * 0.4 + 0.8) * TILE_SIZE, color: '#1e5b3a' },
                        { dy: -TILE_SIZE * 0.3, radius: (Math.random() * 0.4 + 0.7) * TILE_SIZE, color: '#277a4d' },
                        { dy: -TILE_SIZE * 0.5, radius: (Math.random() * 0.3 + 0.6) * TILE_SIZE, color: '#2e8b57' },
                    ]
                });
            }
            scenery.trees.sort((a, b) => a.y - b.y);
        }

        function createVehicles() {
            vehicles = [];
            const lanes = [
                { y: ROAD_CENTER_Y - TILE_SIZE * 1.8, speed: -2.8 },
                { y: ROAD_CENTER_Y + TILE_SIZE * 0.3, speed: 2.2 },
            ];
            lanes.forEach(lane => {
                const numVehicles = Math.floor(Math.random() * 2) + 4;
                for (let i = 0; i < numVehicles; i++) {
                    const typeKey = weightedVehicleTypes[Math.floor(Math.random() * weightedVehicleTypes.length)];
                    const template = vehicleTemplates[typeKey];
                    const vehicle = {
                        type: typeKey,
                        x: Math.random() * canvas.width * 1.5 + i * (canvas.width * 1.8 / numVehicles),
                        y: lane.y,
                        width: TILE_SIZE * template.width,
                        height: TILE_SIZE * template.heightMultiplier,
                        baseSpeed: lane.speed,
                        color: carColors[Math.floor(Math.random() * carColors.length)],
                        wheelRot: Math.random() * Math.PI * 2,
                    };
                    if (vehicle.type === 'bicycle') {
                        vehicle.pedalPhase = Math.random() * Math.PI * 2;
                    }
                    vehicles.push(vehicle);
                }
            });
        }

        const nameInput = document.getElementById('playerNameInput');
        if (nameInput) {
            nameInput.addEventListener('input', () => { playerName = nameInput.value.trim(); });
        }
        playGameBtn.addEventListener('click', () => {
            playerName = (nameInput && nameInput.value.trim()) || playerName;
            startGame();
        });
        document.addEventListener("keydown", e => handleInput(e.key));
        document.addEventListener('keydown', e => {
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });

        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            document.body.classList.add('touch-enabled');
        }

        mobileControls.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                handleInput(e.target.dataset.key);
            }
        });
        const pauseBtn = document.getElementById('pauseBtn');
        pauseBtn.addEventListener('click', () => togglePause());

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            if (gameOver) {
                restartGame();
                return;
            }
            touchStartX = e.changedTouches[0].clientX;
            touchStartY = e.changedTouches[0].clientY;
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            touchEndX = e.changedTouches[0].clientX;
            touchEndY = e.changedTouches[0].clientY;
            handleSwipe();
        }, { passive: false });


        window.addEventListener('resize', () => {
            setTimeout(() => {
                const wasRunning = gameStarted && !gameOver;
                const wasGameOver = gameOver;

                init();

                if (wasRunning) {
                    gameStarted = true;
                    requestAnimationFrame(gameLoop);
                } else if (wasGameOver) {
                    gameStarted = true;
                    gameOver = true;
                    draw();
                }
            }, 250);
        });


        function handleSwipe() {
            if (gameOver) return;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            const swipeThreshold = 30;

            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > swipeThreshold) {
                    handleInput(dx > 0 ? 'ArrowRight' : 'ArrowLeft');
                }
            } else {
                if (Math.abs(dy) > swipeThreshold) {
                    handleInput(dy > 0 ? 'ArrowDown' : 'ArrowUp');
                }
            }
        }

        function handleInput(key) {
            if (gameOver) {
                if (key === "Enter") {
                    restartGame();
                }
                return;
            }
            if (paused) return;

            if (!newt) return;

            if (!gameStarted) {
                startGame();
                return;
            }

            switch (key) {
                case "ArrowUp": newt.y -= newt.speed; newt.targetRotation = 0; break;
                case "ArrowDown": if (newt.y < canvas.height - newt.height * 2) newt.y += newt.speed; newt.targetRotation = Math.PI; break;
                case "ArrowLeft": if (newt.x > 0) newt.x -= newt.speed; newt.targetRotation = -Math.PI / 2; break;
                case "ArrowRight": if (newt.x < canvas.width - newt.width) newt.x += newt.speed; newt.targetRotation = Math.PI / 2; break;
            }
        }

        function togglePause() {
            if (!gameStarted || gameOver) return;
            paused = !paused;
            const btn = document.getElementById('pauseBtn');
            if (btn) btn.textContent = paused ? '▶' : '⏸';
        }

        function update(deltaTime) {
            if (gameOver) return;
            if (gameStarted && newt) {
                newt.walkPhase = (gameTime / 200) % (Math.PI * 2);
            }
            if (newt) {
                let dy = newt.targetRotation - newt.rotation;
                if (Math.abs(dy) > Math.PI) dy = dy < 0 ? dy + 2 * Math.PI : dy - 2 * Math.PI;
                newt.rotation += dy * 0.2;
            }

            const difficultyFactor = Math.min(3.5, 1 + score * 0.08);

            vehicles.forEach(v => {
                const speedPxPerSec = v.baseSpeed * BASE_SPEED_SCALAR * canvas.width * difficultyFactor;
                v.x += speedPxPerSec * deltaTime;
                if (v.type !== 'bicycle') {
                    const wheelRadius = v.height * 0.16;
                    v.wheelRot = (v.wheelRot + (speedPxPerSec * deltaTime) / Math.max(1, wheelRadius)) % (Math.PI * 2);
                }

                if (v.type === 'bicycle') {
                    const pedalSpeed = 0.2;
                    v.pedalPhase = (v.pedalPhase + pedalSpeed) % (Math.PI * 2);
                }
                if (v.baseSpeed > 0 && v.x > canvas.width + v.width) v.x = -v.width;
                else if (v.baseSpeed < 0 && v.x < -v.width * 2) v.x = canvas.width + v.width;
            });

            vehicles.forEach(v => {
                if (newt && newt.x < v.x + v.width && newt.x + newt.width > v.x && newt.y < v.y + v.height && newt.y + newt.height > v.y) {
                    handleCollision();
                }
            });

            if (newt && newt.y < ROAD_TOP_Y) {
                handleSuccess();
            }

            updateCleaner();
        }

        function activateCleaner(splat) {
            cleaner.isActive = true;
            cleaner.targetSplat = splat;
            cleaner.state = 'entering';

            const startOnLeft = splat.x < canvas.width / 2;
            cleaner.x = startOnLeft ? -cleaner.width * 2 : canvas.width + cleaner.width * 2;
            cleaner.y = ROAD_BOTTOM_Y + TILE_SIZE;
            cleaner.direction = startOnLeft ? 'right' : 'left';
        }

        function updateCleaner() {
            if (!cleaner.isActive) return;

            cleaner.walkPhase = (gameTime / 150) % (Math.PI * 2);
            const cleaningDuration = 1500;

            const isExiting = cleaner.state === 'exiting';
            const targetX = isExiting ? (cleaner.exitSide === 'left' ? -cleaner.width * 2 : canvas.width + cleaner.width) : cleaner.targetSplat.x - cleaner.width / 2;
            const targetY = isExiting ? ROAD_BOTTOM_Y + TILE_SIZE : cleaner.targetSplat.y - cleaner.height / 2;

            const dx = targetX - cleaner.x;
            const dy = targetY - cleaner.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (cleaner.state === 'cleaning') {
                if (gameTime - cleaner.cleaningStartTime > cleaningDuration) {
                    scenery.splats = scenery.splats.filter(s => s.id !== cleaner.targetSplat.id);
                    cleaner.targetSplat = null;
                    cleaner.state = 'exiting';
                    cleaner.exitSide = cleaner.x < canvas.width / 2 ? 'right' : 'left';
                }
                return;
            }

            if (distance < cleaner.speed * 1.5) {
                if (!isExiting) {
                    cleaner.state = 'cleaning';
                    cleaner.cleaningStartTime = gameTime;
                } else {
                    cleaner.isActive = false;
                    cleaner.state = 'idle';
                    if (scenery.splats.length > 0) {
                        activateCleaner(scenery.splats[0]);
                    }
                }
                return;
            }

            let canMove = true;
            let moveX = 0;
            let moveY = 0;

            if (Math.abs(dy) > cleaner.speed) {
                moveY = Math.sign(dy) * cleaner.speed;
            } else {
                moveX = Math.sign(dx) * cleaner.speed;
                cleaner.direction = moveX > 0 ? 'right' : 'left';

                if (cleaner.y > ROAD_TOP_Y && cleaner.y < ROAD_BOTTOM_Y) {
                    const safetyBuffer = TILE_SIZE * 4;
                    for (const v of vehicles) {
                        if (Math.abs(v.y - cleaner.y) < TILE_SIZE * 1.5) {
                            const cleanerFront = cleaner.x + (cleaner.direction === 'right' ? cleaner.width : 0);

                            if (cleaner.direction === 'right' && v.baseSpeed < 0 && v.x + v.width > cleanerFront && v.x < cleanerFront + safetyBuffer) {
                                canMove = false;
                                break;
                            }
                            if (cleaner.direction === 'left' && v.baseSpeed > 0 && v.x < cleanerFront && v.x + v.width > cleanerFront - safetyBuffer) {
                                canMove = false;
                                break;
                            }
                        }
                    }
                }
            }

            if (canMove) {
                cleaner.x += moveX;
                cleaner.y += moveY;
            }
        }

        function handleCollision() {
            if (!newt) return;

            hitFlashUntil = gameTime + 250;

            const newSplat = {
                x: newt.x + newt.width / 2,
                y: newt.y + newt.height / 2,
                creationTime: gameTime,
                maxRadius: TILE_SIZE * 0.8,
                id: Date.now() + Math.random()
            };
            scenery.splats.push(newSplat);

            if (!cleaner.isActive) {
                activateCleaner(newSplat);
            }

            newt = null;
            lives--;

            if (lives <= 0) {
                gameOver = true;

                gtag('event', 'game_over', {
                    'event_category': 'Game',
                    'event_label': 'Player Lost',
                    'value': score
                });

                submitScore();
                fetchLeaderboard(true);
            } else {
                setTimeout(resetNewt, 500);
            }
        }

        function handleSuccess() {
            score++;
            resetNewt();

            gtag('event', 'newt_crossed', {
                'event_category': 'Game',
                'event_label': 'Successful Crossing',
                'value': score
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();

            scenery.splats.forEach(drawSplat);
            drawHumanCleaner();

            vehicles.forEach(v => {
                const template = vehicleTemplates[v.type];
                template.draw(v);
            });

            if (gameStarted && !gameOver && newt) {
                drawNewt(newt.x, newt.y, newt.width, newt.height);
            }

            drawUI();

            if (gameOver) {
                drawGameOver();
            }
        }

        function drawNewt(x, y, w, h) {
            ctx.save();
            ctx.translate(x + w / 2, y + h / 2);
            ctx.rotate(newt.rotation);

            const walkCycle = Math.sin(newt.walkPhase);
            const legShift = walkCycle * (w * 0.08);
            const legColor = "#af7d1c";
            const legLength = w * 0.3;
            const legThickness = h * 0.15;
            const bodySide = w * 0.35;

            ctx.fillStyle = legColor;
            ctx.fillRect(-bodySide - legLength + legShift, -h * 0.2, legLength, legThickness);
            ctx.fillRect(bodySide + legShift, h * 0.2 - legThickness, legLength, legThickness);
            ctx.fillRect(bodySide - legShift, -h * 0.2, legLength, legThickness);
            ctx.fillRect(-bodySide - legLength - legShift, h * 0.2 - legThickness, legLength, legThickness);

            ctx.fillStyle = "#cf8e23";
            ctx.beginPath();
            ctx.ellipse(0, h * 0.6, w * 0.2, h * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#e59f28";
            ctx.beginPath();
            ctx.ellipse(0, 0, w * 0.45, h * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "#f5d47a";
            ctx.beginPath();
            ctx.ellipse(0, 0, w * 0.35, h * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#e59f28";
            ctx.beginPath();
            ctx.ellipse(0, -h * 0.4, w * 0.4, h * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(-w * 0.15, -h * 0.45, w * 0.05, 0, Math.PI * 2);
            ctx.arc(w * 0.15, -h * 0.45, w * 0.05, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawHumanCleaner() {
            if (!cleaner.isActive) return;

            ctx.save();
            ctx.translate(cleaner.x, cleaner.y);

            const w = cleaner.width;
            const h = cleaner.height;
            const walkCycle = Math.sin(cleaner.walkPhase);
            const bob = Math.sin(cleaner.walkPhase * 2) * (TILE_SIZE * 0.05);

            ctx.strokeStyle = "#a0522d";
            ctx.lineWidth = w * 0.1;
            ctx.beginPath();
            ctx.moveTo(w * 0.5, h * 0.5 + bob);
            const mopAngle = cleaner.direction === 'right' ? Math.PI / 4 : (3 * Math.PI) / 4;
            const mopEndX = w * 0.5 + Math.cos(mopAngle) * w;
            const mopEndY = h * 0.5 + bob + Math.sin(mopAngle) * w;
            ctx.lineTo(mopEndX, mopEndY);
            ctx.stroke();

            if (cleaner.state === 'cleaning') {
                const cleaningProgress = (gameTime - cleaner.cleaningStartTime) / 1000;
                const mopHeadX = cleaner.targetSplat.x - cleaner.x + Math.sin(cleaningProgress * Math.PI * 6) * (w * 0.5);
                const mopHeadY = cleaner.targetSplat.y - cleaner.y;
                ctx.fillStyle = "#e6e6e6";
                ctx.beginPath();
                ctx.ellipse(mopHeadX, mopHeadY, w * 0.4, w * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = "#2c3e50";
            const legShift = walkCycle * (w * 0.2);
            ctx.fillRect(w * 0.3 - legShift, h * 0.6 + bob, w * 0.2, h * 0.4);
            ctx.fillRect(w * 0.5 + legShift, h * 0.6 + bob, w * 0.2, h * 0.4);

            ctx.fillStyle = "#f39c12";
            ctx.fillRect(w * 0.15, h * 0.2 + bob, w * 0.7, h * 0.4);

            ctx.fillStyle = "#bdc3c7";
            ctx.fillRect(w * 0.1, h * 0.4 + bob, w * 0.8, h * 0.08);

            ctx.fillStyle = "#f1c40f";
            ctx.beginPath();
            ctx.arc(w * 0.5, h * 0.15 + bob, w * 0.25, Math.PI, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#e67e22";
            ctx.beginPath();
            ctx.arc(w * 0.5, h * 0.15 + bob, w * 0.2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawSplat(splat) {
            const age = gameTime - splat.creationTime;
            const maxLife = 3000;
            const opacity = 1 - (age / maxLife);

            ctx.save();
            ctx.fillStyle = `rgba(107, 142, 35, 0.7)`;
            ctx.beginPath();
            ctx.ellipse(splat.x, splat.y, splat.maxRadius, splat.maxRadius * 0.7, Math.PI / 4, 0, Math.PI * 2);
            ctx.ellipse(splat.x + 5, splat.y - 5, splat.maxRadius * 0.5, splat.maxRadius * 0.8, Math.PI / 2, 0, Math.PI * 2);
            ctx.ellipse(splat.x - 5, splat.y + 5, splat.maxRadius * 0.9, splat.maxRadius * 0.6, -Math.PI / 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawWaitingNewt(x, y, size) {
            ctx.save();
            ctx.fillStyle = "#d95f26";
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.ellipse(x, y, size * 0.4, size * 0.5, 0, 0, Math.PI * 2);
            ctx.ellipse(x, y - size * 0.4, size * 0.3, size * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
            ctx.restore();
        }

        function drawBackground() {
            ctx.fillStyle = "#277a4d";
            ctx.fillRect(0, 0, canvas.width, ROAD_TOP_Y);

            scenery.waitingNewts.forEach(n => drawWaitingNewt(n.x, n.y, n.size));
            scenery.trees.forEach(tree => {
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--trunk-color');
                ctx.fillRect(tree.x - tree.trunkWidth / 2, tree.y - tree.trunkHeight, tree.trunkWidth, tree.trunkHeight);
                tree.canopyLayers.forEach(layer => {
                    ctx.fillStyle = layer.color;
                    ctx.beginPath();
                    ctx.arc(tree.x, tree.y - tree.trunkHeight + layer.dy, layer.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
            });

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--road-color');
            ctx.fillRect(0, ROAD_TOP_Y, canvas.width, ROAD_BOTTOM_Y - ROAD_TOP_Y);

            ctx.strokeStyle = 'rgba(255,255,255,0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, ROAD_TOP_Y + 2);
            ctx.lineTo(canvas.width, ROAD_TOP_Y + 2);
            ctx.moveTo(0, ROAD_BOTTOM_Y - 2);
            ctx.lineTo(canvas.width, ROAD_BOTTOM_Y - 2);
            ctx.stroke();

            ctx.font = `bold ${TILE_SIZE * 0.8}px 'Poppins'`;
            ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Alma Bridge Road", canvas.width / 2, ROAD_CENTER_Y);

            ctx.strokeStyle = "#ffd700";
            ctx.lineWidth = 6;
            ctx.setLineDash([TILE_SIZE * 0.8, TILE_SIZE * 0.9]);
            ctx.beginPath();
            ctx.moveTo(0, ROAD_CENTER_Y);
            ctx.lineTo(canvas.width, ROAD_CENTER_Y);
            ctx.stroke();
            ctx.setLineDash([]);

            const waterY = ROAD_BOTTOM_Y;
            const waterHeight = canvas.height - waterY;
            const grad = ctx.createLinearGradient(0, waterY, 0, canvas.height);
            grad.addColorStop(0, "#3b6fa5");
            grad.addColorStop(1, "#2a4d75");
            ctx.fillStyle = grad;
            ctx.fillRect(0, waterY, canvas.width, waterHeight);

            ctx.font = `bold ${TILE_SIZE * 0.8}px 'Poppins'`;
            ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Lexington Reservoir", canvas.width / 2, waterY + waterHeight / 2);
        }

        function drawCar(vehicle) {
            const { x, y, width: w, height: h, color, baseSpeed: speed, wheelRot } = vehicle;
            ctx.save();
            ctx.translate(x, y);

            drawMotionStreak(speed, w, h);

            ctx.fillStyle = 'rgba(0,0,0,0.22)';
            ctx.beginPath();
            ctx.ellipse(w / 2, h * 0.92, (w / 2) * 1.1, h * 0.16, 0, 0, Math.PI * 2);
            ctx.fill();

            drawWheel(w * 0.22, h * 0.86, h * 0.18, wheelRot);
            drawWheel(w * 0.78, h * 0.86, h * 0.18, wheelRot);

            const grad = ctx.createLinearGradient(0, h * 0.3, 0, h * 0.8);
            grad.addColorStop(0, lighten(color, 0.15));
            grad.addColorStop(1, darken(color, 0.15));
            ctx.fillStyle = grad;
            ctx.roundRect(0, h * 0.3, w, h * 0.5, h * 0.12);
            ctx.fill();

            const glassGrad = ctx.createLinearGradient(0, h * 0.08, 0, h * 0.35);
            glassGrad.addColorStop(0, 'rgba(240, 248, 255, 0.95)');
            glassGrad.addColorStop(1, 'rgba(180, 210, 230, 0.65)');
            ctx.fillStyle = glassGrad;
            ctx.beginPath();
            const cabinX = w * 0.12;
            const cabinW = w * 0.76;
            ctx.moveTo(cabinX, h * 0.32);
            ctx.lineTo(cabinX + w * 0.12, h * 0.08);
            ctx.lineTo(cabinX + cabinW - w * 0.12, h * 0.08);
            ctx.lineTo(cabinX + cabinW, h * 0.32);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = 'rgba(255,255,255,0.35)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(w * 0.05, h * 0.55);
            ctx.lineTo(w * 0.95, h * 0.55);
            ctx.stroke();

            if (speed > 0) {
                drawHeadlight(w - 2, h * 0.55, h * 0.12);
                drawTaillight(2, h * 0.55, h * 0.12);
            } else {
                drawHeadlight(2, h * 0.55, h * 0.12);
                drawTaillight(w - 2, h * 0.55, h * 0.12);
            }
            ctx.restore();
        }

        function drawTruck(vehicle) {
            const { x, y, width: w, height: h, color, baseSpeed: speed, wheelRot } = vehicle;
            ctx.save();
            ctx.translate(x, y);

            drawMotionStreak(speed, w, h);

            ctx.fillStyle = 'rgba(0,0,0,0.22)';
            ctx.beginPath();
            ctx.ellipse(w / 2, h * 0.92, (w / 2) * 1.05, h * 0.16, 0, 0, Math.PI * 2);
            ctx.fill();

            const cabWidth = w * 0.28;
            const sleeperWidth = w * 0.18;
            const trailerWidth = w * 0.54;
            const gap = w * 0.02;
            const cabX = speed > 0 ? trailerWidth + gap + sleeperWidth : 0;
            const sleeperX = speed > 0 ? trailerWidth + gap : cabWidth;
            const trailerX = speed > 0 ? 0 : cabWidth + sleeperWidth + gap;
            const cabFrontX = speed > 0 ? cabX + cabWidth : cabX;
            const trailerBackX = speed > 0 ? trailerX : trailerX + trailerWidth;

            const trailerGrad = ctx.createLinearGradient(0, h * 0.08, 0, h * 0.9);
            trailerGrad.addColorStop(0, '#dfe5e8');
            trailerGrad.addColorStop(0.5, '#c4ccd0');
            trailerGrad.addColorStop(1, '#9aa2a6');
            ctx.fillStyle = trailerGrad;
            ctx.roundRect(trailerX, h * 0.08, trailerWidth, h * 0.82, h * 0.04);
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.08)';
            ctx.lineWidth = 1;
            for (let i = 1; i < 5; i++) {
                const px = trailerX + (trailerWidth * i) / 5;
                ctx.beginPath();
                ctx.moveTo(px, h * 0.1);
                ctx.lineTo(px, h * 0.88);
                ctx.stroke();
            }
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(trailerX + trailerWidth * 0.04, h * 0.78, trailerWidth * 0.92, h * 0.1);

            const sleeperGrad = ctx.createLinearGradient(0, h * 0.18, 0, h * 0.85);
            sleeperGrad.addColorStop(0, darken(color, 0.05));
            sleeperGrad.addColorStop(1, darken(color, 0.25));
            ctx.fillStyle = sleeperGrad;
            ctx.roundRect(sleeperX, h * 0.18, sleeperWidth, h * 0.74, h * 0.08);
            ctx.fill();

            const cabGrad = ctx.createLinearGradient(0, h * 0.18, 0, h * 0.9);
            cabGrad.addColorStop(0, lighten(color, 0.2));
            cabGrad.addColorStop(1, darken(color, 0.2));
            ctx.fillStyle = cabGrad;
            ctx.roundRect(cabX, h * 0.2, cabWidth, h * 0.72, h * 0.12);
            ctx.fill();

            ctx.fillStyle = 'rgba(230,245,255,0.9)';
            ctx.beginPath();
            if (speed > 0) {
                ctx.moveTo(cabX + cabWidth * 0.2, h * 0.22);
                ctx.lineTo(cabX + cabWidth * 0.95, h * 0.22);
                ctx.lineTo(cabX + cabWidth * 0.78, h * 0.5);
                ctx.lineTo(cabX + cabWidth * 0.2, h * 0.5);
            } else {
                ctx.moveTo(cabX + cabWidth * 0.05, h * 0.22);
                ctx.lineTo(cabX + cabWidth * 0.8, h * 0.22);
                ctx.lineTo(cabX + cabWidth * 0.8, h * 0.5);
                ctx.lineTo(cabX + cabWidth * 0.22, h * 0.5);
            }
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#555';
            const stackX = speed > 0 ? sleeperX + sleeperWidth * 0.15 : sleeperX + sleeperWidth * 0.85;
            ctx.fillRect(stackX - w * 0.01, h * 0.05, w * 0.02, h * 0.3);
            ctx.fillStyle = '#999';
            ctx.fillRect(stackX - w * 0.012, h * 0.03, w * 0.024, h * 0.05);

            const rear1 = trailerX + trailerWidth * 0.3;
            const rear2 = trailerX + trailerWidth * 0.5;
            const rear3 = trailerX + trailerWidth * 0.7;
            const front = cabX + cabWidth * 0.55;
            const wy = h * 0.9;
            drawWheel(rear1, wy, h * 0.15, wheelRot);
            drawWheel(rear2, wy, h * 0.15, wheelRot + 0.5);
            drawWheel(rear3, wy, h * 0.15, wheelRot + 1.0);
            drawWheel(front, wy, h * 0.16, wheelRot);

            drawHeadlight(cabFrontX, h * 0.55, h * 0.16);
            drawTaillight(trailerBackX, h * 0.55, h * 0.16);
            ctx.restore();
        }

        function drawHeadlight(x, y, size) {
            const glowSize = size * 2.5;
            const lightGradient = ctx.createRadialGradient(x, y, size * 0.2, x, y, glowSize);
            lightGradient.addColorStop(0, 'rgba(255, 255, 224, 1)');
            lightGradient.addColorStop(0.3, 'rgba(255, 255, 224, 0.8)');
            lightGradient.addColorStop(1, 'rgba(255, 255, 224, 0)');
            ctx.fillStyle = lightGradient;
            ctx.fillRect(x - glowSize, y - glowSize, glowSize * 2, glowSize * 2);
        }

        function drawTaillight(x, y, size) {
            const glowSize = size * 2;
            const lightGradient = ctx.createRadialGradient(x, y, size * 0.3, x, y, glowSize);
            lightGradient.addColorStop(0, 'rgba(255, 20, 20, 1)');
            lightGradient.addColorStop(0.5, 'rgba(200, 0, 0, 0.5)');
            lightGradient.addColorStop(1, 'rgba(150, 0, 0, 0)');
            ctx.fillStyle = lightGradient;
            ctx.fillRect(x - glowSize, y - glowSize, glowSize * 2, glowSize * 2);
        }

        function drawKayakCar(vehicle) {
            drawCar(vehicle);
            const { x, y, width: w, height: h } = vehicle;
            ctx.fillStyle = "#d95f26";
            ctx.beginPath();
            ctx.ellipse(x + w / 2, y + h * 0.05, w * 0.4, h * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMotorcycle(vehicle) {
            const { x, y, width: w, height: h, color, baseSpeed, wheelRot } = vehicle;
            ctx.save();
            ctx.translate(x, y);

            drawMotionStreak(baseSpeed, w, h);

            ctx.fillStyle = 'rgba(0,0,0,0.18)';
            ctx.beginPath();
            ctx.ellipse(w / 2, h * 0.88, w / 2, h * 0.12, 0, 0, Math.PI * 2);
            ctx.fill();

            drawWheel(w * 0.15, h * 0.78, h * 0.2, wheelRot);
            drawWheel(w * 0.85, h * 0.78, h * 0.2, wheelRot);

            const frameGrad = ctx.createLinearGradient(0, h * 0.3, 0, h * 0.8);
            frameGrad.addColorStop(0, lighten(color, 0.1));
            frameGrad.addColorStop(1, darken(color, 0.1));
            ctx.fillStyle = frameGrad;
            ctx.beginPath();
            ctx.moveTo(w * 0.15, h * 0.75);
            ctx.lineTo(w * 0.42, h * 0.4);
            ctx.lineTo(w * 0.85, h * 0.75);
            ctx.closePath();
            ctx.fill();

            const riderCenterX = w * 0.5;
            const riderBodyY = h * 0.05;
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(riderCenterX - w * 0.1, riderBodyY + h * 0.3, w * 0.2, h * 0.4);
            ctx.fillStyle = '#B71C1C';
            ctx.beginPath();
            ctx.moveTo(riderCenterX - w * 0.2, riderBodyY + h * 0.5);
            ctx.lineTo(riderCenterX - w * 0.1, riderBodyY);
            ctx.lineTo(riderCenterX + w * 0.2, riderBodyY);
            ctx.lineTo(riderCenterX + w * 0.1, riderBodyY + h * 0.5);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#B71C1C';
            ctx.lineWidth = w * 0.15;
            ctx.beginPath();
            const handlebarX = baseSpeed > 0 ? riderCenterX + w * 0.35 : riderCenterX - w * 0.35;
            ctx.moveTo(riderCenterX, riderBodyY + h * 0.1);
            ctx.lineTo(handlebarX, h * 0.4);
            ctx.stroke();

            ctx.fillStyle = '#37474F';
            ctx.beginPath();
            ctx.arc(riderCenterX, riderBodyY, h * 0.18, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(230, 245, 255, 0.8)';
            const visorX = baseSpeed > 0 ? riderCenterX + h * 0.05 : riderCenterX - h * 0.15;
            ctx.fillRect(visorX, riderBodyY - h * 0.08, h * 0.1, h * 0.12);

            const headX = baseSpeed > 0 ? w - 2 : 2;
            drawHeadlight(headX, h * 0.55, h * 0.13);

            ctx.restore();
        }

        function drawWheel(cx, cy, r, rot = 0) {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(rot);
            ctx.translate(-cx, -cy);
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(cx, cy, r * 0.45, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#bbb';
            ctx.beginPath();
            ctx.arc(cx, cy, r * 0.18, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = r * 0.1;
            for (let i = 0; i < 4; i++) {
                const a = (Math.PI / 2) * i;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(a) * r * 0.85, cy + Math.sin(a) * r * 0.85);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawMotionStreak(speed, w, h) {
            const strength = Math.min(1, Math.abs(speed) * 0.6);
            if (strength <= 0.01) return;
            ctx.save();
            const streakW = w * 0.6 * strength;
            const grad = ctx.createLinearGradient(0, 0, streakW, 0);
            if (speed > 0) {
                grad.addColorStop(0, 'rgba(255,255,255,0.0)');
                grad.addColorStop(1, 'rgba(255,255,255,0.08)');
                ctx.fillStyle = grad;
                ctx.fillRect(-streakW, h * 0.35, streakW, h * 0.4);
            } else {
                grad.addColorStop(0, 'rgba(255,255,255,0.08)');
                grad.addColorStop(1, 'rgba(255,255,255,0.0)');
                ctx.fillStyle = grad;
                ctx.fillRect(w, h * 0.35, streakW, h * 0.4);
            }
            ctx.restore();
        }

        function lighten(hex, amt) {
            const { r, g, b } = hexToRgb(hex);
            return rgbToHex(
                Math.min(255, Math.round(r + 255 * amt)),
                Math.min(255, Math.round(g + 255 * amt)),
                Math.min(255, Math.round(b + 255 * amt))
            );
        }
        function darken(hex, amt) {
            const { r, g, b } = hexToRgb(hex);
            return rgbToHex(
                Math.max(0, Math.round(r * (1 - amt))),
                Math.max(0, Math.round(g * (1 - amt))),
                Math.max(0, Math.round(b * (1 - amt)))
            );
        }
        function hexToRgb(hex) {
            const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (!m) return { r: 200, g: 200, b: 200 };
            return { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) };
        }
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
        }

        function drawBicycle(vehicle) {
            const { x, y, width: w, height: h, color, baseSpeed, pedalPhase } = vehicle;
            ctx.save();
            ctx.translate(x, y);

            ctx.strokeStyle = '#555'; ctx.lineWidth = w * 0.08;
            ctx.beginPath();
            ctx.arc(w * 0.15, h * 0.8, h * 0.18, 0, Math.PI * 2);
            ctx.arc(w * 0.85, h * 0.8, h * 0.18, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = color; ctx.lineWidth = w * 0.06;
            ctx.beginPath();
            ctx.moveTo(w * 0.15, h * 0.8);
            ctx.lineTo(w * 0.5, h * 0.4);
            ctx.lineTo(w * 0.85, h * 0.8);
            ctx.stroke();

            const bodyBob = Math.sin(pedalPhase * 2) * (h * 0.05);
            const riderX = w * 0.5;
            const riderY = h * 0.15 + bodyBob;

            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(riderX - w * 0.15, riderY, w * 0.3, h * 0.4);

            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(riderX, riderY, h * 0.15, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#e0aA77';
            ctx.lineWidth = w * 0.08;
            ctx.beginPath();
            const handlebarX = baseSpeed > 0 ? riderX + w * 0.25 : riderX - w * 0.25;
            ctx.moveTo(riderX, riderY + h * 0.2);
            ctx.lineTo(handlebarX, h * 0.5);
            ctx.stroke();

            const hipY = riderY + h * 0.4;
            const crankX = w * 0.5;
            const crankY = h * 0.8;
            const pedalRadius = h * 0.18;

            const pedal1X = crankX + pedalRadius * Math.cos(pedalPhase);
            const pedal1Y = crankY + pedalRadius * Math.sin(pedalPhase);
            ctx.beginPath();
            ctx.moveTo(riderX, hipY);
            ctx.lineTo(pedal1X, pedal1Y);
            ctx.stroke();

            const pedal2X = crankX + pedalRadius * Math.cos(pedalPhase + Math.PI);
            const pedal2Y = crankY + pedalRadius * Math.sin(pedalPhase + Math.PI);
            ctx.beginPath();
            ctx.moveTo(riderX, hipY);
            ctx.lineTo(pedal2X, pedal2Y);
            ctx.stroke();


            ctx.restore();
        }


        function drawUI() {
            ctx.save();
            ctx.font = `600 ${TILE_SIZE * 0.5}px 'Poppins'`;

            ctx.textAlign = "left";
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.roundRect(15, 15, TILE_SIZE * 3.5, TILE_SIZE * 1, 10);
            ctx.fill();
            ctx.fillStyle = "white";
            ctx.fillText(`Score: ${score}`, 25, 15 + TILE_SIZE * 0.65);

            ctx.textAlign = "right";
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.roundRect(canvas.width - TILE_SIZE * 3.5 - 15, 15, TILE_SIZE * 3.5, TILE_SIZE * 1, 10);
            ctx.fill();
            ctx.fillStyle = "white";
            ctx.fillText(`Lives: ${lives}`, canvas.width - 25, 15 + TILE_SIZE * 0.65);

            // Center panel: player's global best and global top
            ctx.textAlign = "center";
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.roundRect(canvas.width / 2 - TILE_SIZE * 4, 15, TILE_SIZE * 8, TILE_SIZE * 1, 10);
            ctx.fill();
            ctx.fillStyle = "white";
            const topGlobal = leaderboardEntries.length ? leaderboardEntries[0].score : 0;
            const centerText = playerName ? `${playerName} Best: ${globalHighScoreForPlayer || 0}  |  Global Top: ${topGlobal}` : `Global Top: ${topGlobal}`;
            ctx.fillText(centerText, canvas.width / 2, 15 + TILE_SIZE * 0.65);

            ctx.restore();

            if (gameTime < hitFlashUntil) {
                ctx.save();
                ctx.fillStyle = 'rgba(255,0,0,0.18)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            if (paused && !gameOver) {
                drawPauseOverlay();
            }
        }

        function drawGameOver() {
            ctx.fillStyle = "rgba(26, 26, 42, 0.85)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--danger-color');
            ctx.textAlign = "center";
            ctx.font = `bold ${TILE_SIZE * 1.5}px 'Poppins'`;
            ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - TILE_SIZE * 1.5);

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-color');
            ctx.font = `600 ${TILE_SIZE * 0.8}px 'Poppins'`;
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 - TILE_SIZE * 0.2);

            if (playerName) {
                ctx.fillStyle = "#f0f0f0";
                ctx.font = `400 ${TILE_SIZE * 0.6}px 'Poppins'`;
                ctx.fillText(`${playerName} Best: ${globalHighScoreForPlayer || score}`, canvas.width / 2, canvas.height / 2 + TILE_SIZE * 0.6);
            }

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-color');
            ctx.font = `600 ${TILE_SIZE * 0.6}px 'Poppins'`;
            ctx.fillText('Top 5 Global', canvas.width / 2, canvas.height / 2 + TILE_SIZE * 1.8);
            ctx.font = `400 ${TILE_SIZE * 0.5}px 'Poppins'`;
            leaderboardEntries.forEach((e, i) => {
                ctx.fillStyle = '#fff';
                const medal = i === 0 ? '🥇 ' : i === 1 ? '🥈 ' : i === 2 ? '🥉 ' : '';
                ctx.fillText(`${medal}${e.name}: ${e.score}`, canvas.width / 2, canvas.height / 2 + TILE_SIZE * (2.4 + i * 0.6));
            });
            ctx.fillStyle = "white";
            ctx.font = `400 ${TILE_SIZE * 0.5}px 'Poppins'`;
            ctx.fillText("Tap or Press Enter to Restart", canvas.width / 2, canvas.height / 2 + TILE_SIZE * (2.5 + leaderboardEntries.length * 0.6));
        }


        function gameLoop(timestamp) {
            if (!lastFrameTime) {
                lastFrameTime = timestamp;
            }
            let deltaTime = (timestamp - lastFrameTime) / 1000;
            lastFrameTime = timestamp;
            gameTime = timestamp;

            if (gameOver) {
                draw();
                return;
            }
            if (paused) {
                draw();
                requestAnimationFrame(gameLoop);
                return;
            }

            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function drawPauseOverlay() {
            ctx.fillStyle = 'rgba(26, 26, 42, 0.6)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-color');
            ctx.textAlign = 'center';
            ctx.font = `bold ${TILE_SIZE * 1.3}px 'Poppins'`;
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - TILE_SIZE * 0.5);
            ctx.fillStyle = '#fff';
            ctx.font = `400 ${TILE_SIZE * 0.6}px 'Poppins'`;
            ctx.fillText('Press P or tap ▶ to resume', canvas.width / 2, canvas.height / 2 + TILE_SIZE * 0.6);
        }

        init();

    </script>
</body>

</html>
